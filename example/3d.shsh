ESC=$(printf '\033')
COLS=$(tput cols)
ROWS=$(tput lines)

# Configuration
CUBE_SIZE=220
PROJ_SCALE=120
PROJ_DIST=2500

# Rotation state
angle_x=0; angle_y=0; angle_z=0
rot_x=5; rot_y=4; rot_z=3

# DVD-style bouncing position (fixed-point × 1000)
pos_x=$((COLS * 500)); pos_y=$((ROWS * 500))
vel_x=700; vel_y=700
MIN_X=$((COLS * 180)); MAX_X=$((COLS * 820))
MIN_Y=$((ROWS * 220)); MAX_Y=$((ROWS * 780))

# Sin lookup table (0-90° in 5° steps, scaled ×1000)
array_init SIN 0 87 174 259 342 423 500 574 643 707 766 819 866 906 940 966 985 996 1000

# Cube vertices: 8 corners at ±CUBE_SIZE
CS=$CUBE_SIZE; CN=$((-CUBE_SIZE))
array_init Vx  $CN $CS $CS $CN  $CN $CS $CS $CN
array_init Vy  $CN $CN $CS $CS  $CN $CN $CS $CS
array_init Vz  $CN $CN $CN $CN  $CS $CS $CS $CS

# Cube edges: 12 lines connecting vertices
array_init E1  0 1 2 3  4 5 6 7  0 1 2 3
array_init E2  1 2 3 0  5 6 7 4  4 5 6 7

# Projected vertex positions
array_init Px 0 0 0 0 0 0 0 0
array_init Py 0 0 0 0 0 0 0 0
array_init Pz 0 0 0 0 0 0 0 0

# Fixed-point trig (×1000)
sin() {
  _d=$(($1 % 360))
  if $_d < 0: _d=$((_d + 360))
  _sign=1
  if $_d >= 180: _d=$((_d - 180)); _sign=-1
  if $_d > 90: _d=$((180 - _d))
  array_get SIN $((_d / 5))
  R=$((R * _sign))
}

cos() { sin $(($1 + 90)); }
mul() { R=$(($1 * $2 / 1000)); }

# Depth-based character shading
depth_char() {
  _z=$1
  if $_z < 1800: R="@"
  elif $_z < 2200: R="#"
  elif $_z < 2600: R="+"
  elif $_z < 3000: R="-"
  else: R="."
}

# Transform all vertices
rotate_and_project() {
  sin $angle_x; _sx=$R; cos $angle_x; _cx=$R
  sin $angle_y; _sy=$R; cos $angle_y; _cy=$R
  sin $angle_z; _sz=$R; cos $angle_z; _cz=$R
  
  _ox=$((pos_x / 1000))
  _oy=$((pos_y / 1000))
  
  _i=0
  while $_i < 8
    # Get vertex coordinates
    array_get Vx $_i; _x=$R
    array_get Vy $_i; _y=$R
    array_get Vz $_i; _z=$R
    
    # Rotate around X axis
    mul $_y $_cx; _t1=$R; mul $_z $_sx; _t2=$R; _ny=$((_t1 - _t2))
    mul $_y $_sx; _t1=$R; mul $_z $_cx; _t2=$R; _nz=$((_t1 + _t2))
    _y=$_ny; _z=$_nz
    
    # Rotate around Y axis
    mul $_x $_cy; _t1=$R; mul $_z $_sy; _t2=$R; _nx=$((_t1 + _t2))
    mul $_x $_sy; _t1=$R; mul $_z $_cy; _t2=$R; _nz=$((_t2 - _t1))
    _x=$_nx; _z=$_nz
    
    # Rotate around Z axis
    mul $_x $_cz; _t1=$R; mul $_y $_sz; _t2=$R; _nx=$((_t1 - _t2))
    mul $_x $_sz; _t1=$R; mul $_y $_cz; _t2=$R; _ny=$((_t1 + _t2))
    _x=$_nx; _y=$_ny
    
    # Perspective projection
    _zd=$((_z + PROJ_DIST))
    if $_zd < 500: _zd=500
    _px=$((_x * PROJ_SCALE / _zd + _ox))
    _py=$((_y * PROJ_SCALE / _zd / 2 + _oy))
    
    # Store projected coordinates
    array_set Px $_i $_px
    array_set Py $_i $_py
    array_set Pz $_i $_zd
    _i++
  done
}

# Bresenham-style line with depth interpolation
draw_line() {
  _lx1=$1; _ly1=$2; _lz1=$3; _lx2=$4; _ly2=$5; _lz2=$6
  
  _dx=$((_lx2 - _lx1)); _dy=$((_ly2 - _ly1)); _dz=$((_lz2 - _lz1))
  _adx=$_dx; if $_adx < 0: _adx=$((-_adx))
  _ady=$_dy; if $_ady < 0: _ady=$((-_ady))
  
  if $_adx > $_ady: _len=$_adx; else _len=$_ady; fi
  if $_len == 0: _len=1
  
  _step=0
  while $_step <= $_len
    _t=$((_step * 1000 / _len))
    _cx=$((_lx1 + _dx * _t / 1000))
    _cy=$((_ly1 + _dy * _t / 1000))
    _cz=$((_lz1 + _dz * _t / 1000))
    
    if $_cx >= 1 && $_cx <= $COLS && $_cy >= 1 && $_cy <= $ROWS
      depth_char $_cz
      printf "${ESC}[%d;%dH%s" "$_cy" "$_cx" "$R"
    fi
    _step++
  done
}

# DVD-style bounce physics
update_physics() {
  angle_x=$(((angle_x + rot_x) % 360))
  angle_y=$(((angle_y + rot_y) % 360))
  angle_z=$(((angle_z + rot_z) % 360))
  
  pos_x=$((pos_x + vel_x))
  pos_y=$((pos_y + vel_y))
  
  if $pos_x < $MIN_X: vel_x=$((-vel_x)); pos_x=$MIN_X; rot_x=$(((rot_x % 4) + 3))
  if $pos_x > $MAX_X: vel_x=$((-vel_x)); pos_x=$MAX_X; rot_y=$(((rot_y % 4) + 3))
  if $pos_y < $MIN_Y: vel_y=$((-vel_y)); pos_y=$MIN_Y; rot_z=$(((rot_z % 3) + 2))
  if $pos_y > $MAX_Y: vel_y=$((-vel_y)); pos_y=$MAX_Y
}

# Render one frame
draw_frame() {
  printf "${ESC}[2J${ESC}[H"
  rotate_and_project
  
  # Draw edges
  _e=0
  while $_e < 12
    array_get E1 $_e; _v1=$R
    array_get E2 $_e; _v2=$R
    
    array_get Px $_v1; _x1=$R
    array_get Py $_v1; _y1=$R
    array_get Pz $_v1; _z1=$R
    array_get Px $_v2; _x2=$R
    array_get Py $_v2; _y2=$R
    array_get Pz $_v2; _z2=$R
    
    draw_line $_x1 $_y1 $_z1 $_x2 $_y2 $_z2
    _e++
  done
  
  # Draw vertices (brighter, on top of edges)
  _v=0
  while $_v < 8
    array_get Px $_v; _vx=$R
    array_get Py $_v; _vy=$R
    array_get Pz $_v; _vz=$R
    if $_vx >= 1 && $_vx <= $COLS && $_vy >= 1 && $_vy <= $ROWS
      depth_char $_vz
      printf "${ESC}[%d;%dH%s" "$_vy" "$_vx" "$R"
    fi
    _v++
  done
  
  printf "${ESC}[%d;1H" "$ROWS"
}

# Main loop
printf "${ESC}[?25l${ESC}[2J"

try
  while true
    draw_frame
    update_physics
    sleep 0.04
  done
catch
  :
end

printf "${ESC}[?25h${ESC}[2J${ESC}[H"
