_test_script="repo/test.shsh"
if file_exists "./shsh.sh"
  _shsh="./shsh.sh"
  _shsh_src="./shsh.shsh"
elif file_exists "../shsh.sh"
  _shsh="../shsh.sh"
  _shsh_src="../shsh.shsh"
else
  _shsh="shsh"
  _shsh_src="shsh.shsh"
end

hex_capture() {
  eval "$1" | od -A n -t x1 -v | tr -d ' \n'
}

echo "=== Arrays ==="

test "array_len" {
  array_add arr "one"
  array_add arr "two"
  array_add arr "three"
  array_len arr
  test_equals "$R" "3"
}

test "array_get 0" {
  array_get arr 0
  test_equals "$R" "one"
}

test "array_get 2" {
  array_get arr 2
  test_equals "$R" "three"
}

test "array_set" {
  array_set arr 1 "TWO"
  array_get arr 1
  test_equals "$R" "TWO"
}

test "array_for count" {
  count=0
  counter() { count=$((count + 1)); }
  array_for arr counter
  test_equals "$count" "3"
}

test "array_clear" {
  array_clear arr
  array_len arr
  test_equals "$R" "0"
}

test "array_clear_full len" {
  array_add full_clear "keep"
  array_add full_clear "drop"
  array_clear_full full_clear
  array_len full_clear
  test_equals "$R" "0"
}

test "array_clear_full empties storage" {
  array_get full_clear 0
  full_clear_ret=$?
  if $full_clear_ret != 0
    test_pass
  else
    test_fail "should remove entries"
  end
}

test "array_clear_full reuse len" {
  array_add full_clear "again"
  array_len full_clear
  test_equals "$R" "1"
}

test "array_clear_full reuse value" {
  array_get full_clear 0
  test_equals "$R" "again"
}

test "array_for empty" {
  array_clear empty_arr
  empty_count=0
  empty_cb() { empty_count=$((empty_count + 1)); }
  array_for empty_arr empty_cb
  test_equals "$empty_count" "0"
}

test "array_delete len" {
  array_clear del_test
  array_add del_test "a"
  array_add del_test "b"
  array_add del_test "c"
  array_delete del_test 1
  array_len del_test
  test_equals "$R" "2"
}

test "array_delete idx0" {
  array_get del_test 0
  test_equals "$R" "a"
}

test "array_delete idx1" {
  array_get del_test 1
  test_equals "$R" "c"
}

test "array_remove negative len" {
  array_clear neg_idx
  array_add neg_idx "keep"
  array_remove neg_idx -1
  neg_ret=$?
  array_len neg_idx
  test_equals "$R" "1"
}

test "array_remove negative index errors" {
  if $neg_ret != 0
    test_pass
  else
    test_fail "should error"
  end
}

test "array_remove len" {
  array_clear rm_test
  array_add rm_test "a"
  array_add rm_test "b"
  array_add rm_test "c"
  array_remove rm_test 1
  array_len rm_test
  test_equals "$R" "2"
}

test "array_remove shifts" {
  array_get rm_test 1
  test_equals "$R" "c"
}

test "array_unset len" {
  array_clear unset_test
  array_add unset_test "x"
  array_add unset_test "y"
  array_add unset_test "z"
  array_unset unset_test 1
  array_len unset_test
  test_equals "$R" "3"
}

test "array_unset leaves hole" {
  array_get unset_test 1
  if "$R" == ""
    test_pass
  else
    test_fail "should leave hole"
  end
}

test "array_unset idx2" {
  array_get unset_test 2
  test_equals "$R" "z"
}

test "array_delete out of bounds returns error" {
  array_clear bounds_del
  array_add bounds_del "only"
  array_delete bounds_del 5
  ret=$?
  if $ret != 0
    test_pass
  else
    test_fail "should error"
  end
}

test "multi delete len" {
  array_clear multi_del
  array_add multi_del "a"
  array_add multi_del "b"
  array_add multi_del "c"
  array_add multi_del "d"
  array_delete multi_del 1
  array_delete multi_del 1
  array_len multi_del
  test_equals "$R" "2"
}

test "multi delete idx0" {
  array_get multi_del 0
  test_equals "$R" "a"
}

test "multi delete idx1" {
  array_get multi_del 1
  test_equals "$R" "d"
}

echo
echo "=== Maps ==="

test "map host" {
  map_set config "host" "localhost"
  map_set config "port" "8080"
  map_get config "host"
  test_equals "$R" "localhost"
}

test "map port" {
  map_get config "port"
  test_equals "$R" "8080"
}

test "map overwrite" {
  map_set config "port" "9000"
  map_get config "port"
  test_equals "$R" "9000"
}

test "map_has existing" {
  if map_has config "host"
    test_pass
  else
    test_fail "should exist"
  end
}

test "map_has missing" {
  if map_has config "invalid_key"
    test_fail "should not exist"
  else
    test_pass
  end
}

test "map_delete" {
  map_set del_map foo "bar"
  map_set del_map baz "qux"
  map_delete del_map foo
  if map_has del_map foo
    test_fail "should be deleted"
  else
    test_pass
  end
}

test "map_delete preserves" {
  map_get del_map baz
  test_equals "$R" "qux"
}

test "empty string" {
  map_set empty "key" ""
  map_get empty "key"
  test_equals "$R" ""
}

test "map_has empty" {
  if map_has empty "key"
    test_pass
  else
    test_fail "should exist"
  end
}

test "zero value" {
  map_set math "zero" 0
  map_get math "zero"
  test_equals "$R" "0"
}

test "map rejects invalid key" {
  map_set badmap "key-with-dash" "value" 2>/dev/null
  ret=$?
  if $ret != 0
    test_pass
  else
    map_get badmap "key-with-dash"
    if "$R" == ""
      test_pass
    else
      test_fail "accepted invalid key"
    end
  end
}

test "map rejects empty key" {
  map_set emptykey "" "val" 2>/dev/null
  ret=$?
  if $ret != 0
    test_pass
  else
    test_fail "accepted empty key"
  end
}

echo
echo "=== Special Values ==="

test "space value 0" {
  array_add spaced "hello world"
  array_add spaced "foo bar baz"
  array_get spaced 0
  test_equals "$R" "hello world"
}

test "space value 1" {
  array_get spaced 1
  test_equals "$R" "foo bar baz"
}

test "glob in arrays" {
  array_add chars "*"
  array_get chars 0
  test_equals "$R" "*"
}

test "glob disabled in is" {
  touch "100" "aaaa"
  val="*"
  if "$val" == "*"
    test_pass
  else
    test_fail "glob active in is"
  end
  rm "100" "aaaa"
}

test "single quote" {
  array_add chars "I'm Here"
  array_get chars 1
  test_equals "$R" "I'm Here"
}

test "double quote" {
  array_add chars 'He said "Hello"'
  array_get chars 2
  test_equals "$R" 'He said "Hello"'
}

test "backslash" {
  bs='path\\to\\file'
  map_set paths "win" "$bs"
  map_get paths "win"
  test_equals "$R" "$bs"
}

test "multiline" {
  ml="line1
line2
line3"
  array_add multi "$ml"
  array_get multi 0
  test_equals "$R" "$ml"
}

test "dash strings" {
  dash_val="-n"
  if "$dash_val" == "-n"
    test_pass
  else
    test_fail "dash strings"
  end
}

test "literal $" {
  price="Costs \$100"
  map_set product "price" "$price"
  map_get product "price"
  test_equals "$R" 'Costs $100'
}

test "tab char" {
  tab_val="a	b"
  map_set tabs "t" "$tab_val"
  map_get tabs "t"
  test_equals "$R" "$tab_val"
}

echo
echo "=== Conditionals ==="

test "n <= 10" {
  n=5
  if $n <= 10
    r1="yes"
  end
  test_equals "$r1" "yes"
}

test "n > 3" {
  n=5
  if $n > 3
    r2="yes"
  end
  test_equals "$r2" "yes"
}

test "n == 5" {
  n=5
  if $n == 5
    r3="yes"
  end
  test_equals "$r3" "yes"
}

test "n != 99" {
  n=5
  if $n != 99
    r4="yes"
  end
  test_equals "$r4" "yes"
}

test "n >= 5" {
  n=5
  if $n >= 5
    r5="yes"
  end
  test_equals "$r5" "yes"
}

test "n < 100" {
  n=5
  if $n < 100
    r6="yes"
  end
  test_equals "$r6" "yes"
}

test "negative less than zero" {
  neg=-10
  if $neg < 0
    test_pass
  else
    test_fail "negative less than zero"
  end
}

test "negative lte" {
  neg=-10
  if $neg <= -10
    test_pass
  else
    test_fail "negative lte"
  end
}

test "negative gt" {
  neg=-10
  if $neg > -20
    test_pass
  else
    test_fail "negative gt"
  end
}

test "string eq" {
  if "apple" == "apple"
    test_pass
  else
    test_fail "string eq"
  end
}

test "string neq" {
  if "apple" != "banana"
    test_pass
  else
    test_fail "string neq"
  end
}

test "empty string eq" {
  empty_str=""
  if "$empty_str" == ""
    test_pass
  else
    test_fail "empty string eq"
  end
}

test "nonempty string neq empty" {
  nonempty="x"
  if "$nonempty" != ""
    test_pass
  else
    test_fail "nonempty string neq empty"
  end
}

test "spaces in if" {
  str="a b"
  if $str == "a b"
    r="match"
  end
  test_equals "$r" "match"
}

test "false positive check" {
  if "a b" == "x y"
    test_fail "false positive"
  else
    test_pass
  end
}

test "operator in value" {
  val="x <= y"
  if "$val" == "x <= y"
    test_pass
  else
    test_fail "operator in value"
  end
}

test "full expression as value" {
  val2="5 < 10"
  if "$val2" == "5 < 10"
    test_pass
  else
    test_fail "full expression as value"
  end
}

echo
echo "=== Chained Conditionals ==="

test "if with && both true" {
  _cc_a=1
  _cc_b=2
  _cc_result=""
  if $_cc_a == 1 && $_cc_b == 2
    _cc_result="both"
  end
  test_equals "$_cc_result" "both"
}

test "if with && first false" {
  _cc_a=0
  _cc_b=2
  _cc_result="none"
  if $_cc_a == 1 && $_cc_b == 2
    _cc_result="both"
  end
  test_equals "$_cc_result" "none"
}

test "if with && second false" {
  _cc_a=1
  _cc_b=0
  _cc_result="none"
  if $_cc_a == 1 && $_cc_b == 2
    _cc_result="both"
  end
  test_equals "$_cc_result" "none"
}

test "if with || first true" {
  _cc_a=1
  _cc_b=0
  _cc_result=""
  if $_cc_a == 1 || $_cc_b == 2
    _cc_result="one"
  end
  test_equals "$_cc_result" "one"
}

test "if with || second true" {
  _cc_a=0
  _cc_b=2
  _cc_result=""
  if $_cc_a == 1 || $_cc_b == 2
    _cc_result="one"
  end
  test_equals "$_cc_result" "one"
}

test "if with || both false" {
  _cc_a=0
  _cc_b=0
  _cc_result="none"
  if $_cc_a == 1 || $_cc_b == 2
    _cc_result="one"
  end
  test_equals "$_cc_result" "none"
}

test "if with && and || mixed" {
  _cc_a=1
  _cc_b=2
  _cc_c=0
  _cc_result=""
  if $_cc_a == 1 && $_cc_b == 2 || $_cc_c == 3
    _cc_result="match"
  end
  test_equals "$_cc_result" "match"
}

test "if with || then && (precedence)" {
  _cc_a=0
  _cc_b=0
  _cc_c=3
  _cc_result=""
  if $_cc_a == 1 || $_cc_b == 2 && $_cc_c == 3
    _cc_result="match"
  end
  test_equals "$_cc_result" ""
}

test "if with three && conditions" {
  _cc_a=1
  _cc_b=2
  _cc_c=3
  _cc_result=""
  if $_cc_a == 1 && $_cc_b == 2 && $_cc_c == 3
    _cc_result="all"
  end
  test_equals "$_cc_result" "all"
}

test "if with three || conditions" {
  _cc_a=0
  _cc_b=0
  _cc_c=3
  _cc_result=""
  if $_cc_a == 1 || $_cc_b == 2 || $_cc_c == 3
    _cc_result="any"
  end
  test_equals "$_cc_result" "any"
}

test "while with && condition" {
  _cc_i=0
  _cc_j=0
  _cc_count=0
  while $_cc_i < 3 && $_cc_j < 2
    _cc_count=$((_cc_count + 1))
    _cc_i=$((_cc_i + 1))
    _cc_j=$((_cc_j + 1))
  done
  test_equals "$_cc_count" "2"
}

test "elif with && condition" {
  _cc_a=0
  _cc_b=2
  _cc_c=3
  _cc_result=""
  if $_cc_a == 1
    _cc_result="first"
  elif $_cc_b == 2 && $_cc_c == 3
    _cc_result="second"
  else
    _cc_result="third"
  end
  test_equals "$_cc_result" "second"
}

test "&& with simple vars" {
  _cc_x="yes"
  _cc_y="also"
  _cc_result=""
  if $_cc_x && $_cc_y
    _cc_result="both set"
  end
  test_equals "$_cc_result" "both set"
}

test "&& with one empty var" {
  _cc_x="yes"
  _cc_y=""
  _cc_result="default"
  if $_cc_x && $_cc_y
    _cc_result="both set"
  end
  test_equals "$_cc_result" "default"
}

test "|| with simple vars" {
  _cc_x=""
  _cc_y="yes"
  _cc_result=""
  if $_cc_x || $_cc_y
    _cc_result="at least one"
  end
  test_equals "$_cc_result" "at least one"
}

test "&& with numeric comparisons" {
  _cc_x=5
  _cc_y=10
  _cc_result=""
  if $_cc_x > 0 && $_cc_y < 20
    _cc_result="in range"
  end
  test_equals "$_cc_result" "in range"
}

test "single-line if with &&" {
  _cc_a=1
  _cc_b=2
  _cc_result=""
  if $_cc_a == 1 && $_cc_b == 2: _cc_result="inline"
  test_equals "$_cc_result" "inline"
}

echo
echo "=== Functions ==="

classify() {
  _cl_x="$1"
  if $_cl_x < 0
    R="negative"
  elif $_cl_x == 0
    R="zero"
  elif $_cl_x <= 10
    R="small"
  else
    R="big"
  end
}

factorial() {
  if $1 <= 1
    R=1
  else
    factorial $(($1 - 1))
    R=$(($1 * R))
  end
}

fib() {
  _fib_a=0 _fib_b=1 _fib_n=$1
  while $_fib_n > 0
    _fib_t=$((_fib_a + _fib_b))
    _fib_a=$_fib_b
    _fib_b=$_fib_t
    _fib_n=$((_fib_n - 1))
  done
  R=$_fib_a
}

test "classify -5" {
  classify -5
  test_equals "$R" "negative"
}

test "classify 0" {
  classify 0
  test_equals "$R" "zero"
}

test "classify 7" {
  classify 7
  test_equals "$R" "small"
}

test "classify 100" {
  classify 100
  test_equals "$R" "big"
}

test "factorial 5" {
  factorial 5
  test_equals "$R" "120"
}

test "factorial 0" {
  factorial 0
  test_equals "$R" "1"
}

test "factorial 10" {
  factorial 10
  test_equals "$R" "3628800"
}

test "fib 10" {
  fib 10
  test_equals "$R" "55"
}

test "fib 0" {
  fib 0
  test_equals "$R" "0"
}

test "fib 1" {
  fib 1
  test_equals "$R" "1"
}

echo
echo "=== Loops ==="

test "while loop" {
  x=0
  _while_sum=0
  while $x < 5
    _while_sum=$((_while_sum + x))
    x=$((x + 1))
  done
  test_equals "$_while_sum" "10"
}

test "while zero iterations" {
  y=10
  _no_iter=0
  while $y < 5
    _no_iter=1
  done
  test_equals "$_no_iter" "0"
}

test "for loop" {
  _for_out=""
  for i in a b c
    _for_out="$_for_out$i"
  done
  test_equals "$_for_out" "abc"
}

test "for single" {
  _single=""
  for s in only
    _single="$s"
  done
  test_equals "$_single" "only"
}

test "nested for" {
  _nested_for=""
  for a in 1 2
    for b in x y
      _nested_for="$_nested_for$a$b"
    done
  done
  test_equals "$_nested_for" "1x1y2x2y"
}

echo
echo "=== Switch ==="

test "switch" {
  _sw_result=""
  for val in foo bar baz qux
    switch $val
    case foo: _sw_result="${_sw_result}F"
    case bar|baz: _sw_result="${_sw_result}B"
    default: _sw_result="${_sw_result}X"
    end
  done
  test_equals "$_sw_result" "FBBX"
}

test "nested switch" {
  _nested_sw=""
  for outer in a b
    for inner in x y
      switch $outer
      case a
        switch $inner
          case x: _nested_sw="${_nested_sw}ax"
          case y: _nested_sw="${_nested_sw}ay"
        end
      case b
          _nested_sw="${_nested_sw}b"
      end
    done
  done
  test_equals "$_nested_sw" "axaybb"
}

test "3-level nested switch" {
  result=""
  for a in 1 2
    switch $a
    case 1
      for b in x y
        switch $b
        case x
          for c in p q
            switch $c
            case p
              result="${result}1xp"
            case q
              result="${result}1xq"
            end
          done
        case y
          result="${result}1y"
        end
      done
    case 2
      result="${result}2"
    end
  done
  test_equals "$result" "1xp1xq1y2"
}

test "switch default only" {
  _def_only=""
  switch "unknown"
  default: _def_only="hit"
  end
  test_equals "$_def_only" "hit"
}

test "switch no match" {
  _no_match="unchanged"
  switch "nomatch"
  case foo: _no_match="foo"
  case bar: _no_match="bar"
  end
  test_equals "$_no_match" "unchanged"
}

echo
echo "=== Tokenizer ==="

test "token count simple" {
  tokenize "(add 1 2)" T1
  array_len T1
  test_equals "$R" "5"
}

test "token 0" {
  array_get T1 0
  test_equals "$R" "("
}

test "token 1" {
  array_get T1 1
  test_equals "$R" "add"
}

test "token 4" {
  array_get T1 4
  test_equals "$R" ")"
}

test "token count nested" {
  tokenize "(define (f x) (+ x 1))" T2
  array_len T2
  test_equals "$R" "12"
}

test "tokenizer quotes" {
  input='(print "a ( b )")'
  tokenize "$input" T_QUOTE
  array_len T_QUOTE
  test_equals "$R" "4"
}

test "tokenizer single quotes" {
  tokenize "(print 'hello ( world )')" T_SQ
  array_len T_SQ
  test_equals "$R" "4"
}

test "tokenizer escapes" {
  tokenize '(test "hello\"world")' T_ESC
  array_len T_ESC
  test_equals "$R" "4"
}

test "tokenizer empty" {
  tokenize "" T_EMPTY
  array_len T_EMPTY
  test_equals "$R" "0"
}

test "tokenizer whitespace" {
  tokenize "   " T_WS
  array_len T_WS
  test_equals "$R" "0"
}

test "tokenizer deep nesting" {
  tokenize "((()))" T_DEEP
  array_len T_DEEP
  test_equals "$R" "6"
}

test "tokenizer atoms" {
  tokenize "foo bar baz" T_ATOMS
  array_len T_ATOMS
  test_equals "$R" "3"
}

test "tokenizer atom 1" {
  array_get T_ATOMS 1
  test_equals "$R" "bar"
}

echo
echo "=== Files ==="

test "file_read" {
  file_write /tmp/shsh_test.txt "hello"
  file_append /tmp/shsh_test.txt "world"
  file_read /tmp/shsh_test.txt
  test_equals "$R" "hello
world"
}

test "file_lines count" {
  file_lines /tmp/shsh_test.txt flines
  array_len flines
  test_equals "$R" "2"
}

test "file_lines 0" {
  array_get flines 0
  test_equals "$R" "hello"
}

test "file_lines 1" {
  array_get flines 1
  test_equals "$R" "world"
}

test "file_each concat" {
  file_write /tmp/shsh_test2.txt "a"
  file_append /tmp/shsh_test2.txt "b"
  file_append /tmp/shsh_test2.txt "c"
  concat=""
  concat_line() { concat="$concat$R"; }
  file_each /tmp/shsh_test2.txt concat_line
  test_equals "$concat" "abc"
}

test "file_exists yes" {
  if file_exists /tmp/shsh_test.txt
    test_pass
  else
    test_fail "file_exists yes"
  end
}

test "file_exists no" {
  if file_exists /tmp/nonexistent_xyz
    test_fail "file_exists no"
  else
    test_pass
  end
}

test "dir_exists yes" {
  if dir_exists /tmp
    test_pass
  else
    test_fail "dir_exists yes"
  end
}

test "dir_exists no" {
  if dir_exists /tmp/nonexistent_xyz
    test_fail "dir_exists no"
  else
    test_pass
  end
}

test "file_read empty" {
  file_write /tmp/shsh_empty.txt ""
  file_read /tmp/shsh_empty.txt
  test_equals "$R" ""
}

test "file special chars" {
  file_write /tmp/shsh_special.txt 'line with $VAR and `cmd`'
  file_read /tmp/shsh_special.txt
  test_equals "$R" 'line with $VAR and `cmd`'
}

test "file_write format literals" {
  fmt_str="%s %d %% literal"
  file_write /tmp/shsh_fmt.txt "$fmt_str"
  file_read /tmp/shsh_fmt.txt
  test_equals "$R" "$fmt_str"
}

test "file_append format literals" {
  fmt_str="%s %d %% literal"
  file_append /tmp/shsh_fmt.txt "$fmt_str"
  file_read /tmp/shsh_fmt.txt
  test_equals "$R" "$fmt_str
$fmt_str"
}

echo
echo "=== AST Basics ==="

test "AST head" {
  array_clear L1
  array_add L1 "add"
  array_add L1 "6"
  array_add L1 "4"
  array_get L1 0
  test_equals "$R" "add"
}

test "AST eval simple" {
  array_get L1 1
  _v1="$R"
  array_get L1 2
  _v2="$R"
  R=$((_v1 + _v2))
  test_equals "$R" "10"
}

echo
echo "=== Sparse Arrays ==="

test "array_len accounts for sparse set" {
  array_clear sparse
  array_add sparse "idx0"
  array_set sparse 10 "idx10"
  array_len sparse
  if $R >= 10
    test_pass
  else
    test_fail "len=$R but idx 10 exists"
  end
}

test "sparse value" {
  array_get sparse 10
  test_equals "$R" "idx10"
}

test "bounds check empty" {
  array_clear bounds_test
  array_add bounds_test "only"
  array_get bounds_test 999
  if "$R" == ""
    test_pass
  else
    test_fail "returned: $R"
  end
}

test "can distinguish empty from missing via return code" {
  array_clear test_arr
  array_add test_arr ""
  array_get test_arr 0
  empty_ret=$?
  array_get test_arr 999
  missing_ret=$?
  if $empty_ret != $missing_ret
    test_pass
  else
    test_fail "empty (ret=$empty_ret) vs missing (ret=$missing_ret) indistinguishable"
  end
}

echo
echo "=== Nested Callbacks ==="

test "nested array_for" {
  array_clear outer_arr
  array_add outer_arr "A"
  array_add outer_arr "B"
  array_clear inner_arr
  array_add inner_arr "1"
  array_add inner_arr "2"
  nested_count=0
  do_inner() { nested_count=$((nested_count + 1)); }
  do_outer() { array_for inner_arr do_inner; }
  array_for outer_arr do_outer
  test_equals "$nested_count" "4"
}

exit_count=0
try_break() {
  exit_count=$((exit_count + 1))
  if "$R" == "b"
    return 1
  end
  return 0
}

test "array_for respects callback return" {
  array_clear exit_test
  array_add exit_test "a"
  array_add exit_test "b"
  array_add exit_test "c"
  exit_count=0
  array_for exit_test try_break
  if $exit_count != 3
    test_pass
  else
    test_fail "no break support"
  end
}

echo
echo "=== Security ==="

test "array index injection blocked" {
  INJECTED="no"
  malicious_index='0; INJECTED="yes"; :'
  array_set exploit_arr "$malicious_index" "payload" 2>/dev/null
  if "$INJECTED" == "yes"
    test_fail "injection occurred"
  else
    test_pass
  end
}

test "map key injection blocked" {
  SAFE_CHECK="ok"
  malicious='valid; SAFE_CHECK="pwned"; :'
  map_set danger "$malicious" "value" 2>/dev/null
  if "$SAFE_CHECK" == "ok"
    test_pass
  else
    test_fail "injection occurred"
  end
}

test "array_add rejects invalid name" {
  array_add "bad-name" "val" 2>/dev/null
  if $? != 0
    test_pass
  else
    test_fail "accepted invalid name"
  end
}

test "cmd substitution stored literally" {
  cmd_val='$(echo pwned)'
  map_set safe "cmd" "$cmd_val"
  map_get safe "cmd"
  test_equals "$R" '$(echo pwned)'
}

echo
echo "=== Nested Transform ==="

nested_transform_test() {
  _inner='if 1 == 1
    R="inner"
  end'
  eval "$(echo "$_inner" | transform)"
}

test "nested transform worked" {
  if 1 == 1
    nested_transform_test
    if "$R" == "inner"
      test_pass
    else
      test_fail "R=$R"
    end
  end
}

echo
echo "=== Multiline ==="

test "multiline comparison" {
  ml="line1
line2"
  ml2="line1
line2"
  if "$ml" == "$ml2"
    test_pass
  else
    test_fail "multiline comparison"
  end
}

test "multiline in map" {
  ml="line1
line2"
  map_set mlmap "key" "$ml"
  map_get mlmap "key"
  test_equals "$R" "$ml"
}

echo
echo "=== Binary Functions ==="

test "bit_8 mixed inputs" {
  got=$(hex_capture 'bit_8 0xff 0x00 10')
  test_equals "$got" "ff000a"
}

test "bit_8 string" {
  got=$(hex_capture 'bit_8 "ABC"')
  test_equals "$got" "414243"
}

test "bit_8 mixed string/hex" {
  got=$(hex_capture 'bit_8 "A" 0x42 "C"')
  test_equals "$got" "414243"
}

test "bit_16 LE" {
  got=$(hex_capture 'bit_16 0x1234')
  test_equals "$got" "3412"
}

test "bit_16 BE" {
  got=$(hex_capture 'ENDIAN=big bit_16 0x1234')
  test_equals "$got" "1234"
}

test "bit_32 LE" {
  got=$(hex_capture 'bit_32 0xAABBCCDD')
  test_equals "$got" "ddccbbaa"
}

test "bit_32 BE" {
  got=$(hex_capture 'ENDIAN=1 bit_32 0xAABBCCDD')
  test_equals "$got" "aabbccdd"
}

test "bit_64 LE" {
  got=$(hex_capture 'bit_64 0x1122334455667788')
  test_equals "$got" "8877665544332211"
}

test "bit_16 variadic" {
  got=$(hex_capture 'bit_16 0x1111 0x2222')
  test_equals "$got" "11112222"
}

test "bit_8 zeros" {
  got=$(hex_capture 'bit_8 0x00 0x00')
  test_equals "$got" "0000"
}

test "bit_16 zero" {
  got=$(hex_capture 'bit_16 0x0000')
  test_equals "$got" "0000"
}

test "bit_32 zero" {
  got=$(hex_capture 'bit_32 0x00000000')
  test_equals "$got" "00000000"
}

test "bit_8 max" {
  got=$(hex_capture 'bit_8 0xff')
  test_equals "$got" "ff"
}

test "bit_16 max" {
  got=$(hex_capture 'bit_16 0xffff')
  test_equals "$got" "ffff"
}

test "bit_64 BE" {
  got=$(hex_capture 'ENDIAN=big bit_64 0x1122334455667788')
  test_equals "$got" "1122334455667788"
}

test "bit_128 LE" {
  got=$(hex_capture 'bit_128 0x112233445566778899aabbccddeeff00')
  test_equals "$got" "00ffeeddccbbaa998877665544332211"
}

test "bit_128 BE" {
  got=$(hex_capture 'ENDIAN=big bit_128 0x112233445566778899aabbccddeeff00')
  test_equals "$got" "112233445566778899aabbccddeeff00"
}

test "bit_128 zero pad" {
  got=$(hex_capture 'bit_128 0xff')
  test_equals "$got" "ff000000000000000000000000000000"
}

test "bit_128 high bit set LE" {
  got=$(hex_capture 'bit_128 0xffffffffffffffffffffffffffffffff')
  test_equals "$got" "ffffffffffffffffffffffffffffffff"
}

test "bit_128 high bit set BE" {
  got=$(hex_capture 'ENDIAN=big bit_128 0xffffffffffffffffffffffffffffffff')
  test_equals "$got" "ffffffffffffffffffffffffffffffff"
}

test "bit_128 alternating LE" {
  got=$(hex_capture 'bit_128 0xaa55aa55aa55aa55aa55aa55aa55aa55')
  test_equals "$got" "55aa55aa55aa55aa55aa55aa55aa55aa"
}

test "bit_128 alternating BE" {
  got=$(hex_capture 'ENDIAN=big bit_128 0xaa55aa55aa55aa55aa55aa55aa55aa55')
  test_equals "$got" "aa55aa55aa55aa55aa55aa55aa55aa55"
}

test "bit_32 four args LE" {
  got=$(hex_capture 'bit_32 0x11223344 0x55667788 0x99aabbcc 0xddeeff00')
  test_equals "$got" "4433221188776655ccbbaa9900ffeedd"
}

test "bit_32 four args BE" {
  got=$(hex_capture 'ENDIAN=big bit_32 0x11223344 0x55667788 0x99aabbcc 0xddeeff00')
  test_equals "$got" "112233445566778899aabbccddeeff00"
}

test "bit_32 five args LE" {
  got=$(hex_capture 'bit_32 0x11223344 0x55667788 0x99aabbcc 0xddeeff00 0xaabbccdd')
  test_equals "$got" "4433221188776655ccbbaa9900ffeeddddccbbaa"
}

test "bit_32 eight args LE" {
  got=$(hex_capture 'bit_32 0x01020304 0x05060708 0x090a0b0c 0x0d0e0f10 0x11121314 0x15161718 0x191a1b1c 0x1d1e1f20')
  test_equals "$got" "04030201080706050c0b0a09100f0e0d14131211181716151c1b1a19201f1e1d"
}

test "bit_32 high bit set LE" {
  got=$(hex_capture 'bit_32 0xffffffff 0x80000000 0x80000001 0xfffffffe')
  test_equals "$got" "ffffffff0000008001000080feffffff"
}

test "bit_128 zero" {
  got=$(hex_capture 'bit_128 0x0')
  test_equals "$got" "00000000000000000000000000000000"
}

echo
echo "=== Edge Cases ==="

test "deep elif chain" {
  deep_val=5
  deep_result=""
  if $deep_val == 1
    deep_result="one"
  elif $deep_val == 2
    deep_result="two"
  elif $deep_val == 3
    deep_result="three"
  elif $deep_val == 4
    deep_result="four"
  elif $deep_val == 5
    deep_result="five"
  else
    deep_result="other"
  end
  test_equals "$deep_result" "five"
}

test "nested if" {
  outer_cond=1
  inner_cond=1
  nested_if_result=""
  if $outer_cond == 1
    if $inner_cond == 1
      nested_if_result="both"
    else
      nested_if_result="outer only"
    end
  else
    nested_if_result="neither"
  end
  test_equals "$nested_if_result" "both"
}

test "large number comparison" {
  big=999999999
  if $big > 999999998
    test_pass
  else
    test_fail "large number comparison"
  end
}

test "large array len" {
  array_clear large_arr
  idx=0
  while $idx < 100
    array_add large_arr "item$idx"
    idx=$((idx + 1))
  done
  array_len large_arr
  test_equals "$R" "100"
}

test "large array last" {
  array_get large_arr 99
  test_equals "$R" "item99"
}

test "rapid map a" {
  map_set rapid "a" "1"
  map_set rapid "b" "2"
  map_set rapid "c" "3"
  map_set rapid "a" "updated"
  map_delete rapid "b"
  map_get rapid "a"
  test_equals "$R" "updated"
}

test "rapid map b deleted" {
  if map_has rapid "b"
    test_fail "should be deleted"
  else
    test_pass
  end
}

test "rapid map c" {
  map_get rapid "c"
  test_equals "$R" "3"
}

echo
echo "=== Defaults ==="

test "default on empty" {
  empty_default=""
  default empty_default "fallback"
  test_equals "$empty_default" "fallback"
}

test "default on unset" {
  unset unset_default 2>/dev/null
  default unset_default "fallback2"
  test_equals "$unset_default" "fallback2"
}

test "default preserves existing" {
  existing_default="original"
  default existing_default "ignored"
  test_equals "$existing_default" "original"
}

test "default zero preserved" {
  zero_default=0
  default zero_default "replaced"
  test_equals "$zero_default" "0"
}

test "default with spaces" {
  space_default="has spaces"
  default space_default "nope"
  test_equals "$space_default" "has spaces"
}

test "default_unset ignores empty" {
  empty_for_unset=""
  default_unset empty_for_unset "should_not_apply"
  test_equals "$empty_for_unset" ""
}

test "default_unset on unset" {
  unset truly_unset 2>/dev/null
  default_unset truly_unset "applied"
  test_equals "$truly_unset" "applied"
}

test "default_unset preserves existing" {
  existing_unset="keep"
  default_unset existing_unset "nope"
  test_equals "$existing_unset" "keep"
}

test "chained default" {
  unset chain_var 2>/dev/null
  default chain_var ""
  default chain_var "second"
  test_equals "$chain_var" "second"
}

test "default special chars" {
  unset special_def 2>/dev/null
  default special_def "hello world"
  test_equals "$special_def" "hello world"
}

test "default rejects invalid name" {
  bad_def_result=$(default "bad-name" "val" 2>&1)
  ret=$?
  if $ret != 0
    test_pass
  else
    test_fail "accepted invalid name"
  end
}

echo
echo "=== Arithmetic Operators ==="

test "var++" {
  inc_var=5
  inc_var++
  test_equals "$inc_var" "6"
}

test "var--" {
  dec_var=10
  dec_var--
  test_equals "$dec_var" "9"
}

test "0++" {
  zero_inc=0
  zero_inc++
  test_equals "$zero_inc" "1"
}

test "0--" {
  neg_dec=0
  neg_dec--
  test_equals "$neg_dec" "-1"
}

test "var += 5" {
  add_var=10
  add_var += 5
  test_equals "$add_var" "15"
}

test "var -= 8" {
  sub_var=20
  sub_var -= 8
  test_equals "$sub_var" "12"
}

test "var *= 6" {
  mul_var=7
  mul_var *= 6
  test_equals "$mul_var" "42"
}

test "var /= 4" {
  div_var=100
  div_var /= 4
  test_equals "$div_var" "25"
}

test "var %= 5" {
  mod_var=17
  mod_var %= 5
  test_equals "$mod_var" "2"
}

test "var += 0" {
  zero_add=42
  zero_add += 0
  test_equals "$zero_add" "42"
}

test "var *= 0" {
  zero_mul=999
  zero_mul *= 0
  test_equals "$zero_mul" "0"
}

test "var *= 1" {
  one_mul=123
  one_mul *= 1
  test_equals "$one_mul" "123"
}

test "var /= 1" {
  one_div=456
  one_div /= 1
  test_equals "$one_div" "456"
}

test "negative += 3" {
  neg_arith=-10
  neg_arith += 3
  test_equals "$neg_arith" "-7"
}

test "var += negative" {
  neg_arith2=5
  neg_arith2 += -10
  test_equals "$neg_arith2" "-5"
}

test "chained arithmetic" {
  chain_arith=10
  chain_arith += 5
  chain_arith *= 2
  chain_arith -= 10
  test_equals "$chain_arith" "20"
}

test "++ in loop" {
  loop_inc=0
  iter=0
  while $iter < 5
    loop_inc++
    iter++
  done
  test_equals "$loop_inc" "5"
}

test "+= loop sum" {
  sum=0
  i=1
  while $i <= 10
    sum += $i
    i++
  done
  test_equals "$sum" "55"
}

test "*= factorial" {
  fact=1
  n=5
  while $n > 1
    fact *= $n
    n--
  done
  test_equals "$fact" "120"
}

test "%= pattern" {
  mod_results=""
  j=0
  while $j < 10
    tmp=$j
    tmp %= 3
    if $tmp == 0
      mod_results="${mod_results}$j "
    end
    j++
  done
  test_equals "$mod_results" "0 3 6 9 "
}

test "large ++" {
  big_inc=999999
  big_inc++
  test_equals "$big_inc" "1000000"
}

test "+= with expr" {
  expr_var=10
  expr_var += $((2 * 3))
  test_equals "$expr_var" "16"
}

test "multiple inc a" {
  multi_a=0
  multi_b=0
  multi_a++
  multi_b++
  multi_a++
  test_equals "$multi_a" "2"
}

test "multiple inc b" {
  test_equals "$multi_b" "1"
}

test "indented arithmetic" {
  indent_var=5
  if 1 == 1
    indent_var++
    indent_var += 10
  end
  test_equals "$indent_var" "16"
}

test "deeply nested arithmetic" {
  nested_arith=0
  if 1 == 1
    if 1 == 1
      if 1 == 1
        nested_arith++
        nested_arith *= 10
        nested_arith += 5
      end
    end
  end
  test_equals "$nested_arith" "15"
}

arith_func() {
  _af_val=$1
  _af_val++
  _af_val *= 2
  R=$_af_val
}

test "arithmetic in function" {
  arith_func 5
  test_equals "$R" "12"
}

test "integer division truncates" {
  trunc_div=7
  trunc_div /= 2
  test_equals "$trunc_div" "3"
}

test "x %= x equals 0" {
  mod_zero=5
  mod_zero %= 5
  test_equals "$mod_zero" "0"
}

test "x %= larger" {
  mod_larger=3
  mod_larger %= 10
  test_equals "$mod_larger" "3"
}

test "++ after semicolon" {
  semi_inc=0
  echo "test" > /dev/null; semi_inc++
  test_equals "$semi_inc" "1"
}

test "-- after semicolon" {
  semi_dec=5
  echo "test" > /dev/null; semi_dec--
  test_equals "$semi_dec" "4"
}

test "+= after semicolon" {
  semi_add=10
  echo "test" > /dev/null; semi_add += 5
  test_equals "$semi_add" "15"
}

test "++ in inline if" {
  inline_if_inc=0
  if true: inline_if_inc++
  test_equals "$inline_if_inc" "1"
}

test "++ after semicolon in inline if" {
  inline_if_semi=0
  if true: echo "ok" > /dev/null; inline_if_semi++
  test_equals "$inline_if_semi" "1"
}

test "-- in inline else" {
  inline_else_dec=10
  if false: inline_else_dec=99
  else: inline_else_dec--
  test_equals "$inline_else_dec" "9"
}

test "+= in inline elif" {
  inline_elif_add=5
  if false: inline_elif_add=0
  elif true: inline_elif_add += 10
  test_equals "$inline_elif_add" "15"
}

_fn_semi_test() {
  echo "in func" > /dev/null; _fn_semi_cnt++
}

test "++ in function after semicolon" {
  _fn_semi_cnt=0
  _fn_semi_test
  test_equals "$_fn_semi_cnt" "1"
}

echo
echo "=== Assignment Syntax (var = func) ==="

test "basic assignment" {
  result = str_before "hello:world" ":"
  test_equals "$result" "hello"
}

test "str_after assignment" {
  result2 = str_after "hello:world" ":"
  test_equals "$result2" "world"
}

test "assignment with vars" {
  _as_input="one:two:three"
  _as_sep=":"
  part1 = str_before "$_as_input" "$_as_sep"
  test_equals "$part1" "one"
}

test "chained assign first" {
  _as_chain="a:b:c:d"
  first = str_before "$_as_chain" ":"
  test_equals "$first" "a"
}

test "chained assign rest" {
  _as_chain="a:b:c:d"
  rest = str_after "$_as_chain" ":"
  test_equals "$rest" "b:c:d"
}

test "chained assign second" {
  _as_chain="a:b:c:d"
  rest = str_after "$_as_chain" ":"
  second = str_before "$rest" ":"
  test_equals "$second" "b"
}

test "str_before_last assign" {
  _as_path="/usr/local/bin/shsh"
  dirname = str_before_last "$_as_path" "/"
  test_equals "$dirname" "/usr/local/bin"
}

test "str_after_last assign" {
  _as_path="/usr/local/bin/shsh"
  basename = str_after_last "$_as_path" "/"
  test_equals "$basename" "shsh"
}

test "str_trim assign" {
  trimmed = str_trim "  spaced  "
  test_equals "$trimmed" "spaced"
}

test "str_ltrim assign" {
  ltrimmed = str_ltrim "  left"
  test_equals "$ltrimmed" "left"
}

test "str_rtrim assign" {
  rtrimmed = str_rtrim "right  "
  test_equals "$rtrimmed" "right"
}

test "str_indent assign" {
  _as_indented="    code here"
  ind = str_indent "$_as_indented"
  test_equals "$ind" "    "
}

test "passthrough string literal" {
  _pt_out=$("$_shsh" raw <<'PTEOF'
x = "literal"
PTEOF
)
  test_equals "$_pt_out" 'x = "literal"'
}

test "passthrough variable" {
  _pt_out2=$("$_shsh" raw <<'PTEOF'
y = $somevar
PTEOF
)
  test_equals "$_pt_out2" 'y = $somevar'
}

test "passthrough empty RHS" {
  _pt_out3=$("$_shsh" raw <<'PTEOF'
z = 
PTEOF
)
  test_equals "$_pt_out3" 'z = '
}

test "passthrough contains equals" {
  _pt_out4=$("$_shsh" raw <<'PTEOF'
eq = has=equals
PTEOF
)
  test_equals "$_pt_out4" 'eq = has=equals'
}

test "indented assignment" {
  if true
    indented_result = str_before "foo:bar" ":"
    test_equals "$indented_result" "foo"
  end
}

test "assignment in loop" {
  _as_items="a b c"
  _as_count=0
  for item in $_as_items
    len = str_before "$item$item" "$item"
    _as_count++
  done
  test_equals "$_as_count" "3"
}

test "multi assign 1" {
  m1 = str_before "x:y" ":"
  test_equals "$m1" "x"
}

test "multi assign 2" {
  m2 = str_after "x:y" ":"
  test_equals "$m2" "y"
}

test "array_len result" {
  array_clear _as_arr
  array_add _as_arr "first"
  array_add _as_arr "second"
  array_len _as_arr
  _as_len="$R"
  test_equals "$_as_len" "2"
}

test "mixed R usage" {
  array_clear _as_arr
  array_add _as_arr "first"
  array_get _as_arr 0
  got = str_before "${R}:" ":"
  test_equals "$got" "first"
}

test "assignment after semicolon" {
  echo "test" > /dev/null; semi_assign = str_before "a:b" ":"
  test_equals "$semi_assign" "a"
}

test "assignment before semicolon" {
  pre_semi = str_after "1:2" ":"; echo "$pre_semi" > /dev/null
  test_equals "$pre_semi" "2"
}

test "multi semicolon assign a" {
  line_a = str_before "p:q" ":"; line_b = str_after "p:q" ":"
  test_equals "$line_a" "p"
}

test "multi semicolon assign b" {
  test_equals "$line_b" "q"
}

test "map_get R capture" {
  map_set _as_map key "value"
  map_get _as_map key
  captured = str_before "${R}!" "!"
  test_equals "$captured" "value"
}

test "regular assignment" {
  regular_var="direct"
  test_equals "$regular_var" "direct"
}

test "+= still works" {
  arith_test=10
  arith_test += 5
  test_equals "$arith_test" "15"
}

test "-= still works" {
  arith_test -= 3
  test_equals "$arith_test" "12"
}

test "underscore var assign" {
  _under_score = str_before "x:y" ":"
  test_equals "$_under_score" "x"
}

test "single char var assign" {
  a = str_before "m:n" ":"
  test_equals "$a" "m"
}

test "long var name assign" {
  very_long_variable_name_here = str_after "start:end" ":"
  test_equals "$very_long_variable_name_here" "end"
}

test "nested step1" {
  _as_nested="one:two:three:four"
  step1 = str_after "$_as_nested" ":"
  test_equals "$step1" "two:three:four"
}

test "nested step2" {
  _as_nested="one:two:three:four"
  step1 = str_after "$_as_nested" ":"
  step2 = str_after "$step1" ":"
  test_equals "$step2" "three:four"
}

test "nested step3" {
  _as_nested="one:two:three:four"
  step1 = str_after "$_as_nested" ":"
  step2 = str_after "$step1" ":"
  step3 = str_before "$step2" ":"
  test_equals "$step3" "three"
}

test "assignment in inline if" {
  _as_if_assign=""
  if true: _as_if_assign = str_before "test:value" ":"
  test_equals "$_as_if_assign" "test"
}

test "assignment in inline while" {
  _as_while_assign=""
  _as_while_cond=1
  while $_as_while_cond == 1: _as_while_assign = str_after "x:y" ":"; _as_while_cond=0
  test_equals "$_as_while_assign" "y"
}

test "assignment special chars" {
  _as_special="hello!@#world"
  spec_result = str_before "$_as_special" "!@#"
  test_equals "$spec_result" "hello"
}

test "assignment spaced value" {
  _as_spaced="first part:second part"
  spaced_result = str_before "$_as_spaced" ":"
  test_equals "$spaced_result" "first part"
}

test "assignment empty result" {
  _as_empty=":after"
  empty_before = str_before "$_as_empty" ":"
  test_equals "$empty_before" ""
}

test "assignment func returns false" {
  _as_nomatch="nocolon"
  if str_before "$_as_nomatch" ":"
    _as_matched="yes"
  else
    _as_matched="no"
  end
  test_equals "$_as_matched" "no"
}

test "combo assign a" {
  _as_combo="aaa:bbb"
  combo_a = str_before "$_as_combo" ":"; combo_b = str_after "$_as_combo" ":"
  test_equals "$combo_a" "aaa"
}

test "combo assign b" {
  test_equals "$combo_b" "bbb"
}

test "numeric suffix var1" {
  var1 = str_before "num:1" ":"
  test_equals "$var1" "num"
}

test "numeric suffix var2" {
  var2 = str_after "num:2" ":"
  test_equals "$var2" "2"
}

test "long args assign" {
  _as_long="a:b:c:d:e"
  long_result = str_before "$_as_long" ":"
  test_equals "$long_result" "a"
}

test "transpile assignment" {
  _as_transpile_out=$("$_shsh" raw <<'TREOF'
foo = str_before "x:y" ":"
TREOF
)
  test_equals "$_as_transpile_out" 'str_before "x:y" ":"; foo="$R"'
}

test "compound ops still work" {
  _as_compound=100
  _as_compound += 50
  _as_compound -= 25
  _as_compound *= 2
  _as_compound /= 5
  test_equals "$_as_compound" "50"
}

echo
echo "=== Single-Line If ==="

test "single if" {
  x=5
  if $x == 5: r1="yes"
  test_equals "$r1" "yes"
}

test "single if/else" {
  x=10
  if $x == 5: r2="five"
  else: r2="not five"
  test_equals "$r2" "not five"
}

test "single if/elif/else" {
  x=15
  if $x < 10: r3="low"
  elif $x < 20: r3="mid"
  else: r3="high"
  test_equals "$r3" "mid"
}

test "single if no match" {
  x=5
  r4="unchanged"
  if $x == 99: r4="changed"
  test_equals "$r4" "unchanged"
}

test "single if then code" {
  x=5
  if $x == 5: r5="match"
  r5="${r5}-after"
  test_equals "$r5" "match-after"
}

test "multi single if 1" {
  if 1 == 1: m1="a"
  test_equals "$m1" "a"
}

test "multi single if 2" {
  if 2 == 2: m2="b"
  test_equals "$m2" "b"
}

test "multi single if 3" {
  if 3 == 3: m3="c"
  test_equals "$m3" "c"
}

test "single if cmd sub" {
  if 1 == 1: cs_result=$(echo "hello")
  test_equals "$cs_result" "hello"
}

test "single if arithmetic" {
  n=10
  if $n > 5: n=$((n * 2))
  test_equals "$n" "20"
}

test "long elif chain" {
  v=4
  if $v == 1: lc="one"
  elif $v == 2: lc="two"
  elif $v == 3: lc="three"
  elif $v == 4: lc="four"
  elif $v == 5: lc="five"
  else: lc="other"
  test_equals "$lc" "four"
}

test "mixed single/multi" {
  x=5
  if $x < 3: mixed="low"
  elif $x < 10
    mixed="mid"
    mixed="${mixed}-multi"
  else: mixed="high"
  end
  test_equals "$mixed" "mid-multi"
}

test "nested single in multi" {
  outer=1
  inner=2
  if $outer == 1
    if $inner == 2: nested="found"
  end
  test_equals "$nested" "found"
}

test "single if in loop" {
  loop_result=""
  for i in 1 2 3
    if $i == 2: loop_result="${loop_result}X"
    else: loop_result="${loop_result}O"
  done
  test_equals "$loop_result" "OXO"
}

test "single if string" {
  s="hello"
  if "$s" == "hello": str_r="match"
  else: str_r="no"
  test_equals "$str_r" "match"
}

test "consecutive single ifs 1" {
  a=1
  if $a == 1: only1="yes"
  test_equals "$only1" "yes"
}

test "consecutive single ifs 2" {
  b=2
  if $b == 2: only2="yes"
  test_equals "$only2" "yes"
}

test "colon in value" {
  if 1 == 1: time_val="12:30:45"
  test_equals "$time_val" "12:30:45"
}

test "single if at eof" {
  eof_test="no"
  if 1 == 1: eof_test="yes"
  test_equals "$eof_test" "yes"
}

echo
echo "=== Single-Line Switch Cases ==="

test "single-line switch basic" {
  _sl1=""
  for val in foo bar baz other
    switch $val
    case foo: _sl1="${_sl1}F"
    case bar|baz: _sl1="${_sl1}B"
    default: _sl1="${_sl1}X"
    end
  done
  test_equals "$_sl1" "FBBX"
}

test "single-line default only" {
  _sl2=""
  switch "unknown"
  default: _sl2="hit"
  end
  test_equals "$_sl2" "hit"
}

test "mixed single/multi switch" {
  _sl3=""
  switch "test"
  case foo: _sl3="F"
  case test
    _sl3="T"
    _sl3="${_sl3}EST"
  default: _sl3="X"
  end
  test_equals "$_sl3" "TEST"
}

test "single-line switch arithmetic" {
  _sl4=0
  for v in a b c d
    switch $v
    case a: _sl4=$((_sl4 + 1))
    case b: _sl4=$((_sl4 + 10))
    case c|d: _sl4=$((_sl4 + 100))
    end
  done
  test_equals "$_sl4" "211"
}

test "single-line switch cmd sub" {
  switch "cmd"
  case cmd: sw_cmd=$(echo "hello")
  default: sw_cmd="no"
  end
  test_equals "$sw_cmd" "hello"
}

test "nested switch single-line" {
  _nested_sw=""
  for outer in a b
    switch $outer
    case a: _nested_sw="${_nested_sw}A"
    case b
      for inner in x y
        switch $inner
        case x: _nested_sw="${_nested_sw}X"
        case y: _nested_sw="${_nested_sw}Y"
        end
      done
    end
  done
  test_equals "$_nested_sw" "AXY"
}

test "switch colon in value" {
  switch "time"
  case time: sw_colon="12:30"
  default: sw_colon="none"
  end
  test_equals "$sw_colon" "12:30"
}

test "single-line switch glob" {
  switch "test123"
  case test*: sw_glob="matched"
  default: sw_glob="no"
  end
  test_equals "$sw_glob" "matched"
}

test "single-line switch no match" {
  _sw_nomatch=""
  switch "xyz"
  case a: _sw_nomatch="a"
  case b: _sw_nomatch="b"
  end
  test_equals "$_sw_nomatch" ""
}

test "all single-line switch" {
  _all_sw=""
  switch "middle"
  case first: _all_sw="1"
  case middle: _all_sw="2"
  case last: _all_sw="3"
  end
  test_equals "$_all_sw" "2"
}

test "switch in if block" {
  _sw_in_if=""
  if 1 == 1
    switch "yes"
    case yes: _sw_in_if="found"
    default: _sw_in_if="no"
    end
  end
  test_equals "$_sw_in_if" "found"
}

test "single-line switch in loop" {
  _sw_loop=""
  for i in 1 2 3
    switch $i
    case 1: _sw_loop="${_sw_loop}A"
    case 2: _sw_loop="${_sw_loop}B"
    case 3: _sw_loop="${_sw_loop}C"
    end
  done
  test_equals "$_sw_loop" "ABC"
}

echo
echo "=== Single-Line Switch Nested Single-Liners ==="

test "default: if:" {
  _nested_default=""
  _skip=0
  switch "x"
    default: if $_skip == 0: _nested_default="works"
  end
  test_equals "$_nested_default" "works"
}

test "default: if skip" {
  _nested_default_skip="stay"
  _skip=1
  switch "x"
    default: if $_skip == 0: _nested_default_skip="changed"
  end
  test_equals "$_nested_default_skip" "stay"
}

test "case: if:" {
  _nested_case=""
  _flag=1
  switch "a"
    case a: if $_flag == 1: _nested_case="yes"
    default: _nested_case="no"
  end
  test_equals "$_nested_case" "yes"
}

test "case: if fallback" {
  _nested_case_fallback="none"
  _flag=0
  switch "b"
    case a: if $_flag == 1: _nested_case_fallback="yes"
    default: _nested_case_fallback="no"
  end
  test_equals "$_nested_case_fallback" "no"
}

test "inline nested elif chain" {
  _inline_chain=""
  switch "branch"
    default: if 0 == 1: _inline_chain="if"
      elif 2 == 2: _inline_chain="elif"
      else: _inline_chain="else"
  end
  test_equals "$_inline_chain" "elif"
}

test "inline nested if closes before following body" {
  _inline_after="start"
  switch "z"
    default: if 1 == 1: _inline_after="set"
  _inline_after="${_inline_after}-post"
  end
  test_equals "$_inline_after" "set-post"
}

test "single-line while increments" {
  _sl_while=""
  _w=0
  while $_w < 3: _sl_while="${_sl_while}${_w}"; _w=$((_w + 1))
  test_equals "$_sl_while" "012"
}

test "single-line while inside switch" {
  _switch_while=""
  switch "go"
    case go:
      _sw_n=1
      while $_sw_n <= 3: _switch_while="${_switch_while}${_sw_n}"; _sw_n=$((_sw_n + 1))
  end
  test_equals "$_switch_while" "123"
}

echo
echo "=== CLI edge cases ==="

test "shsh with no args prints usage" {
  _usage_status=0
  _usage_out=$(sh "$_shsh" 2>&1) || _usage_status=$?
  _usage_expected="usage: shsh"
  if $_usage_status == 0
    if str_contains "$_usage_out" "$_usage_expected"
      test_pass
    else
      test_fail "missing usage text"
    end
  else
    test_fail "status $_usage_status"
  end
}

test "prints inline output" {
  if file_exists "$_shsh"
    _shsh_path="$_shsh"
  elif file_exists "${0%/*}/../shsh.sh"
    _shsh_path="${0%/*}/../shsh.sh"
  elif file_exists "/usr/local/bin/shsh"
    _shsh_path="/usr/local/bin/shsh"
  else
    _shsh_path="$_shsh"
  end
  _dash_c_out=$("$_shsh_path" 'echo hi')
  if "$_dash_c_out" == "hi"
    test_pass
  else
    test_fail "got: '$_dash_c_out'"
  end
}

test "modulo operator" {
  _mod_c_out=$("$_shsh" 'val=$((17 % 5)); echo "$val"' 2>&1)
  if "$_mod_c_out" == "2"
    test_pass
  else
    test_fail "got: '$_mod_c_out'"
  end
}

test "chained modulo" {
  _mod_multi_out=$("$_shsh" 'a=$((100 % 30)); b=$((a % 7)); echo "$b"' 2>&1)
  if "$_mod_multi_out" == "3"
    test_pass
  else
    test_fail "got: '$_mod_multi_out'"
  end
}

test "percent in string" {
  _pct_str_out=$("$_shsh" 'x="50%"; echo "$x"' 2>&1)
  if "$_pct_str_out" == "50%"
    test_pass
  else
    test_fail "got: '$_pct_str_out'"
  end
}

test "raw reads from stdin" {
  _stdin_code="x=7"
  _stdin_t_out=$(printf "%s\n" "$_stdin_code" | "$_shsh" raw -)
  if "$_stdin_t_out" == "$_stdin_code"
    test_pass
  else
    test_fail "got: '$_stdin_t_out'"
  end
}

test "raw with file does not hang" {
  _test_file="/tmp/shsh_cli_test_$$.shsh"
  printf '%s\n' 'x=1' > "$_test_file"
  _transform_out=$("$_shsh" raw "$_test_file" 2>&1)
  rm -f "$_test_file"
  if "$_transform_out" == "x=1"
    test_pass
  else
    test_fail "got: '$_transform_out'"
  end
}

test "printf dash works" {
  _dash_out=$(printf "%s" "-")
  if "$_dash_out" == "-"
    test_pass
  else
    test_fail "got: '$_dash_out'"
  end
}

test "printf double dash works" {
  _dashes_out=$(printf "%s" "--")
  if "$_dashes_out" == "--"
    test_pass
  else
    test_fail "got: '$_dashes_out'"
  end
}

test "printf dash-letter works" {
  _dashopt_out=$(printf "%s" "-d")
  if "$_dashopt_out" == "-d"
    test_pass
  else
    test_fail "got: '$_dashopt_out'"
  end
}

test "semicolon before while should transform" {
  # 'i=0; while $i < 5:' should transform the while, but currently doesn't
  _raw_out=$(printf '%s' 'i=0; while $i < 5: echo hi; i++' | "$_shsh" raw -)
  _check_transformed='while ['
  if str_contains "$_raw_out" "$_check_transformed"
    test_pass  # while was transformed correctly
  else
    test_fail "while not transformed when preceded by semicolon"
  end
}

test "semicolon before if should transform" {
  # 'x=1; if $x == 1:' should transform the if, but currently doesn't
  _raw_out=$(printf '%s' 'x=1; if $x == 1: echo yes; end' | "$_shsh" raw -)
  _check_transformed='if ['
  if str_contains "$_raw_out" "$_check_transformed"
    test_pass  # if was transformed correctly
  else
    test_fail "if not transformed when preceded by semicolon"
  end
}

test "semicolon before for should transform" {
  # 'x=0; for i in 1 2 3:' should transform the for, but currently doesn't
  _raw_out=$(printf '%s' 'x=0; for i in 1 2 3: echo $i; end' | "$_shsh" raw -)
  # for loops should transform colon to 'do' and 'end' to 'done'
  if str_contains "$_raw_out" "do" && str_contains "$_raw_out" "done"
    # Also verify the colon is gone
    if ! str_contains "$_raw_out" "3:"
      test_pass  # for was transformed correctly
    else
      test_fail "for not transformed when preceded by semicolon"
    end
  else
    test_fail "for not transformed when preceded by semicolon"
  end
}

test "should read from stdin" {
  # build - should read from stdin like raw - does
  _build_stdin=$(printf '%s\n' 'echo hello' | "$_shsh" build - 2>&1) || true
  if str_contains "$_build_stdin" "echo"
    test_pass  # stdin works
  else
    test_fail "build - does not read stdin: $_build_stdin"
  end
}

test "same-line end in while should be removed" {
  # 'while $i < 5: echo hi; end' produces both 'end' AND 'done'
  _raw_out=$(printf 'while $i < 5: echo hi; end' | "$_shsh" raw -)
  # Should NOT contain literal 'end' word (only 'done')
  if str_contains "$_raw_out" "; end"
    test_fail "end not removed from same line: $_raw_out"
  else
    test_pass
  end
}

test "same-line end in if should be removed" {
  # 'if $x == 1: echo yes; end' produces both 'end' AND 'fi'
  _raw_out=$(printf 'if $x == 1: echo yes; end' | "$_shsh" raw -)
  # Should NOT contain literal 'end' word (only 'fi')
  if str_contains "$_raw_out" "; end"
    test_fail "end not removed from same line: $_raw_out"
  else
    test_pass
  end
}

test "pipe before while should transform" {
  # 'echo hi | while read line:' should transform the while
  _raw_out=$(printf 'echo hi | while read line: echo $line; end' | "$_shsh" raw -)
  if str_contains "$_raw_out" "do" && str_contains "$_raw_out" "done"
    test_pass
  else
    test_fail "pipe before while not transformed: $_raw_out"
  end
}

test "&& before if should transform" {
  # 'true && if $x == 1:' should transform the if
  _raw_out=$(printf 'true && if $x == 1: echo yes; end' | "$_shsh" raw -)
  if str_contains "$_raw_out" "if [" && str_contains "$_raw_out" "fi"
    test_pass
  else
    test_fail "&& before if not transformed: $_raw_out"
  end
}

test "colon-space in string should not transform" {
  # Literal ": " inside a string should NOT be treated as syntax
  # We use a variable here because the bug affects the test file itself!
  _colon_space=":"
  _colon_space="$_colon_space "
  _raw_out=$(printf '%s\n' "if str_contains \"\$x\" \"$_colon_space\"" | "$_shsh" raw -)
  # Should pass through unchanged (or just add 'then' for if, not treat ": " as body separator)
  if str_contains "$_raw_out" "str_contains \"\$x\" \"$_colon_space\""
    test_pass
  else
    test_fail "colon-space in string was transformed: $_raw_out"
  end
}

# This one should PASS - it's the workaround that currently works
test "workaround: newline before while transforms correctly" {
  _raw_nl=$(printf 'i=0\nwhile $i < 5: echo hi; i++' | "$_shsh" raw -)
  _check_transformed='while ['
  if str_contains "$_raw_nl" "$_check_transformed"
    test_pass
  else
    test_fail "while not transformed"
  end
}

echo
echo "=== Runtime Helpers ==="

test "file_executable detects non-exec" {
  _rt_tmp="/tmp/shsh_rt_$$"
  printf '%s\n' "echo hi" > "$_rt_tmp"
  if file_executable "$_rt_tmp"
    test_fail "false negative"
  else
    test_pass
  end
}

test "file_executable detects exec" {
  _rt_tmp="/tmp/shsh_rt_$$"
  chmod +x "$_rt_tmp"
  if file_executable "$_rt_tmp"
    test_pass
  else
    test_fail "misses exec"
  end
  rm -f "$_rt_tmp"
}

test "path_writable current dir" {
  if path_writable "$PWD"
    test_pass
  else
    test_fail "should be writable"
  end
}

test "path_writable protected path" {
  if path_writable "/root"
    test_fail "should not be writable"
  else
    test_pass
  end
}

echo
echo "=== Map Enumeration ==="

test "map_keys count" {
  map_set enum_map alpha "1"
  map_set enum_map beta "2"
  map_set enum_map gamma "3"
  map_keys enum_map enum_keys
  array_len enum_keys
  test_equals "$R" "3"
}

_found_alpha=0 _found_beta=0 _found_gamma=0
check_enum_key() {
  switch $R
  case alpha: _found_alpha=1
  case beta:  _found_beta=1
  case gamma: _found_gamma=1
  end
}

test "map_keys contains all keys" {
  _found_alpha=0 _found_beta=0 _found_gamma=0
  array_for enum_keys check_enum_key
  if $_found_alpha == 1
    if $_found_beta == 1
      if $_found_gamma == 1
        test_pass
      else
        test_fail "missing keys (a=$_found_alpha b=$_found_beta g=$_found_gamma)"
      end
    else
      test_fail "missing keys (a=$_found_alpha b=$_found_beta g=$_found_gamma)"
    end
  else
    test_fail "missing keys (a=$_found_alpha b=$_found_beta g=$_found_gamma)"
  end
}

test "map_keys empty" {
  map_keys empty_map empty_keys 2>/dev/null
  array_len empty_keys
  test_equals "$R" "0"
}

test "map_keys after delete count" {
  map_set del_enum_map a "1"
  map_set del_enum_map b "2"
  map_set del_enum_map c "3"
  map_delete del_enum_map b
  map_keys del_enum_map del_enum_keys
  array_len del_enum_keys
  test_equals "$R" "2"
}

_has_a=0 _has_b=0 _has_c=0
check_del_key() {
  switch $R
  case a: _has_a=1
  case b: _has_b=1
  case c: _has_c=1
  end
}

test "map_keys excludes deleted" {
  _has_a=0 _has_b=0 _has_c=0
  array_for del_enum_keys check_del_key
  if $_has_a == 1
    if $_has_b == 0
      if $_has_c == 1
        test_pass
      else
        test_fail "delete handling (a=$_has_a b=$_has_b c=$_has_c)"
      end
    else
      test_fail "delete handling (a=$_has_a b=$_has_b c=$_has_c)"
    end
  else
    test_fail "delete handling (a=$_has_a b=$_has_b c=$_has_c)"
  end
}

test "map_keys no duplicates" {
  map_set dup_map key "first"
  map_set dup_map key "second"
  map_set dup_map key "third"
  map_keys dup_map dup_keys
  array_len dup_keys
  test_equals "$R" "1"
}

test "map_keys single key" {
  array_get dup_keys 0
  test_equals "$R" "key"
}

test "map overwrite value" {
  map_get dup_map key
  test_equals "$R" "third"
}

_for_sum=0
_for_keys=""
sum_map() {
  _for_sum=$((_for_sum + R))
  _for_keys="${_for_keys}${K}"
}

test "map_for sum values" {
  map_set for_map x "10"
  map_set for_map y "20"
  map_set for_map z "30"
  _for_sum=0
  _for_keys=""
  map_for for_map sum_map
  test_equals "$_for_sum" "60"
}

test "map_for visits all keys" {
  switch $_for_keys
  case *x*y*z*|*x*z*y*|*y*x*z*|*y*z*x*|*z*x*y*|*z*y*x*: test_pass
  case *: test_fail "incomplete: $_for_keys"
  end
}

test "map_for empty" {
  _empty_visited=0
  empty_cb() { _empty_visited=1; }
  map_for nonexistent_map empty_cb 2>/dev/null
  test_equals "$_empty_visited" "0"
}

_exit_count=0
exit_after_two() {
  _exit_count=$((_exit_count + 1))
  if $_exit_count >= 2
    return 1
  end
  return 0
}

test "map_for early exit" {
  map_set exit_map a "1"
  map_set exit_map b "2"
  map_set exit_map c "3"
  _exit_count=0
  map_for exit_map exit_after_two
  test_equals "$_exit_count" "2"
}

test "map_for skips deleted" {
  map_set fd_map p "1"
  map_set fd_map q "2"
  map_set fd_map r "3"
  map_delete fd_map q
  _fd_vals=""
  collect_fd() { _fd_vals="${_fd_vals}${R}"; }
  map_for fd_map collect_fd
  switch $_fd_vals
  case 13|31: test_pass
  case *: test_fail "got: $_fd_vals"
  end
}

test "map_for K and R correct" {
  map_set kr_map foo "FOO"
  map_set kr_map bar "BAR"
  _kr_pairs=""
  check_kr() { _kr_pairs="${_kr_pairs}${K}=${R} "; }
  map_for kr_map check_kr
  switch $_kr_pairs
  case *foo=FOO*bar=BAR*|*bar=BAR*foo=FOO*: test_pass
  case *: test_fail "K/R mismatch: $_kr_pairs"
  end
}

test "map_keys refresh" {
  map_set twice_map a "1"
  map_keys twice_map twice_keys1
  map_set twice_map b "2"
  map_keys twice_map twice_keys2
  array_len twice_keys2
  test_equals "$R" "2"
}

test "large map keys" {
  _large_i=0
  while $_large_i < 50
    map_set large_map "key$_large_i" "val$_large_i"
    _large_i=$((_large_i + 1))
  done
  map_keys large_map large_keys
  array_len large_keys
  test_equals "$R" "50"
}

test "large map_for count" {
  _large_count=0
  count_large() { _large_count=$((_large_count + 1)); }
  map_for large_map count_large
  test_equals "$_large_count" "50"
}

test "single map keys" {
  map_set single_map only "value"
  map_keys single_map single_keys
  array_len single_keys
  test_equals "$R" "1"
}

test "single map key value" {
  array_get single_keys 0
  test_equals "$R" "only"
}

test "single map_for K" {
  _single_k="" _single_v=""
  get_single() { _single_k="$K"; _single_v="$R"; }
  map_for single_map get_single
  test_equals "$_single_k" "only"
}

test "single map_for R" {
  test_equals "$_single_v" "value"
}

test "reuse after delete count" {
  map_set reuse_map a "1"
  map_set reuse_map b "2"
  map_delete reuse_map a
  map_delete reuse_map b
  map_set reuse_map c "3"
  map_keys reuse_map reuse_keys
  array_len reuse_keys
  test_equals "$R" "1"
}

test "reuse after delete key" {
  array_get reuse_keys 0
  test_equals "$R" "c"
}

test "map_keys rejects invalid map name" {
  map_keys "bad-name" out 2>/dev/null
  ret=$?
  if $ret != 0
    test_pass
  else
    test_fail "accepted invalid map name"
  end
}

test "map_keys rejects invalid output name" {
  map_keys valid_map "bad-out" 2>/dev/null
  ret=$?
  if $ret != 0
    test_pass
  else
    test_fail "accepted invalid output name"
  end
}

test "map_for rejects invalid name" {
  map_for "bad-name" echo 2>/dev/null
  ret=$?
  if $ret != 0
    test_pass
  else
    test_fail "accepted invalid name"
  end
}

test "nested map_for" {
  map_set outer_m a "1"
  map_set outer_m b "2"
  map_set inner_m x "10"
  map_set inner_m y "20"
  _nested_sum=0
  inner_sum() { _nested_sum=$((_nested_sum + R)); }
  outer_iter() { map_for inner_m inner_sum; }
  map_for outer_m outer_iter
  test_equals "$_nested_sum" "60"
}

test "empty value map_keys" {
  map_set empty_val_map key ""
  map_keys empty_val_map ev_keys
  array_len ev_keys
  test_equals "$R" "1"
}

test "empty value visited" {
  _ev_visited=0
  check_empty_val() { _ev_visited=1; }
  map_for empty_val_map check_empty_val
  test_equals "$_ev_visited" "1"
}

test "zero value map_for" {
  map_set zero_val_map num "0"
  _zv=""
  get_zero() { _zv="$R"; }
  map_for zero_val_map get_zero
  test_equals "$_zv" "0"
}

test "stable after bad delete" {
  map_set stable_map exists "yes"
  map_delete stable_map never_existed
  map_keys stable_map stable_keys
  array_len stable_keys
  test_equals "$R" "1"
}

test "re-add deleted key count" {
  map_set readd_map key "first"
  map_delete readd_map key
  map_set readd_map key "second"
  map_keys readd_map readd_keys
  array_len readd_keys
  test_equals "$R" "1"
}

test "re-add deleted value" {
  map_get readd_map key
  test_equals "$R" "second"
}

test "map_clear keys" {
  map_set clear_map a "1"
  map_set clear_map b "2"
  map_clear clear_map
  map_keys clear_map clear_keys
  array_len clear_keys
  test_equals "$R" "0"
}

test "map_clear value gone" {
  map_get clear_map a
  test_equals "$R" ""
}

test "map_clear re-add" {
  map_set clear_map fresh "new"
  map_keys clear_map clear_keys2
  array_len clear_keys2
  test_equals "$R" "1"
}

echo
echo "=== String Functions ==="

test "str_starts basic match" {
  if str_starts "hello world" "hello"
    test_pass
  else
    test_fail "should match"
  end
}

test "str_starts no false positive" {
  if str_starts "hello world" "world"
    test_fail "false positive"
  else
    test_pass
  end
}

test "str_starts exact match" {
  if str_starts "hello" "hello"
    test_pass
  else
    test_fail "should match"
  end
}

test "str_starts empty prefix" {
  if str_starts "hello" ""
    test_pass
  else
    test_fail "should match"
  end
}

test "str_starts empty string empty prefix" {
  if str_starts "" ""
    test_pass
  else
    test_fail "should match"
  end
}

test "str_starts empty string non-empty prefix" {
  if str_starts "" "x"
    test_fail "should not match"
  else
    test_pass
  end
}

test "str_starts prefix longer than string" {
  if str_starts "hello" "hello world"
    test_fail "should not match"
  else
    test_pass
  end
}

test "str_starts with spaces" {
  if str_starts "  spaces" "  "
    test_pass
  else
    test_fail "should match"
  end
}

test "str_starts with slash" {
  if str_starts "path/to/file" "path/"
    test_pass
  else
    test_fail "should match"
  end
}

test "str_starts with glob chars" {
  if str_starts "***glob" "***"
    test_pass
  else
    test_fail "should match"
  end
}

test "str_ends basic match" {
  if str_ends "hello world" "world"
    test_pass
  else
    test_fail "should match"
  end
}

test "str_ends no false positive" {
  if str_ends "hello world" "hello"
    test_fail "false positive"
  else
    test_pass
  end
}

test "str_ends exact match" {
  if str_ends "hello" "hello"
    test_pass
  else
    test_fail "should match"
  end
}

test "str_ends empty suffix" {
  if str_ends "hello" ""
    test_pass
  else
    test_fail "should match"
  end
}

test "str_ends empty string empty suffix" {
  if str_ends "" ""
    test_pass
  else
    test_fail "should match"
  end
}

test "str_ends empty string non-empty suffix" {
  if str_ends "" "x"
    test_fail "should not match"
  else
    test_pass
  end
}

test "str_ends suffix longer than string" {
  if str_ends "hello" "hello world"
    test_fail "should not match"
  else
    test_pass
  end
}

test "str_ends with extension" {
  if str_ends "file.txt" ".txt"
    test_pass
  else
    test_fail "should match"
  end
}

test "str_ends with spaces" {
  if str_ends "trailing  " "  "
    test_pass
  else
    test_fail "should match"
  end
}

test "str_ends with glob chars" {
  if str_ends "end***" "***"
    test_pass
  else
    test_fail "should match"
  end
}

test "str_contains middle" {
  if str_contains "hello world" "o w"
    test_pass
  else
    test_fail "should match"
  end
}

test "str_contains start" {
  if str_contains "hello world" "hello"
    test_pass
  else
    test_fail "should match"
  end
}

test "str_contains end" {
  if str_contains "hello world" "world"
    test_pass
  else
    test_fail "should match"
  end
}

test "str_contains no false positive" {
  if str_contains "hello world" "xyz"
    test_fail "false positive"
  else
    test_pass
  end
}

test "str_contains exact match" {
  if str_contains "hello" "hello"
    test_pass
  else
    test_fail "should match"
  end
}

test "str_contains empty needle" {
  if str_contains "hello" ""
    test_pass
  else
    test_fail "should match"
  end
}

test "str_contains empty both" {
  if str_contains "" ""
    test_pass
  else
    test_fail "should match"
  end
}

test "str_contains empty haystack" {
  if str_contains "" "x"
    test_fail "should not match"
  else
    test_pass
  end
}

test "str_contains asterisk" {
  if str_contains "abc*def" "*"
    test_pass
  else
    test_fail "should match"
  end
}

test "str_contains question mark" {
  if str_contains "a?b" "?"
    test_pass
  else
    test_fail "should match"
  end
}

test "str_contains bracket" {
  if str_contains "[test]" "["
    test_pass
  else
    test_fail "should match"
  end
}

test "str_after first slash" {
  str_after "path/to/file" "/"
  test_equals "$R" "to/file"
}

test "str_after equals" {
  str_after "key=value" "="
  test_equals "$R" "value"
}

test "str_after returns false on no match" {
  str_after "hello" "x"
  ret=$?
  if $ret != 0
    test_pass
  else
    test_fail "should return false"
  end
}

test "str_after first occurrence" {
  str_after "aaa" "a"
  test_equals "$R" "aa"
}

test "str_after space" {
  str_after "hello world" " "
  test_equals "$R" "world"
}

test "str_after leading delimiter" {
  str_after "::value" ":"
  test_equals "$R" ":value"
}

test "str_after trailing delimiter" {
  str_after "value::" ":"
  test_equals "$R" ":"
}

test "str_after no match returns false" {
  str_after "no-delim" "="
  ret=$?
  if $ret != 0
    test_pass
  else
    test_fail "should return false"
  end
}

test "str_after no match sets R to original" {
  str_after "no-delim" "="
  test_equals "$R" "no-delim"
}

test "str_after multi-char delimiter" {
  str_after "a::b" "::"
  test_equals "$R" "b"
}

test "str_after empty string" {
  str_after "" "x"
  ret=$?
  if $ret != 0
    test_pass
  else
    test_fail "should fail"
  end
}

test "str_before first slash" {
  str_before "path/to/file" "/"
  test_equals "$R" "path"
}

test "str_before equals (first only)" {
  str_before "key=value=extra" "="
  test_equals "$R" "key"
}

test "str_before returns false on no match" {
  str_before "hello" "x"
  ret=$?
  if $ret != 0
    test_pass
  else
    test_fail "should return false"
  end
}

test "str_before space" {
  str_before "hello world" " "
  test_equals "$R" "hello"
}

test "str_before leading delimiter" {
  str_before "::value" ":"
  test_equals "$R" ""
}

test "str_before trailing delimiter" {
  str_before "value::" ":"
  test_equals "$R" "value"
}

test "str_before multi-char delimiter" {
  str_before "a::b" "::"
  test_equals "$R" "a"
}

test "str_before empty string" {
  str_before "" "x"
  ret=$?
  if $ret != 0
    test_pass
  else
    test_fail "should fail"
  end
}

test "str_after_last slash" {
  str_after_last "path/to/file" "/"
  test_equals "$R" "file"
}

test "str_after_last dot extension" {
  str_after_last "a.b.c.txt" "."
  test_equals "$R" "txt"
}

test "str_after_last returns false on no match" {
  str_after_last "hello" "x"
  ret=$?
  if $ret != 0
    test_pass
  else
    test_fail "should return false"
  end
}

test "str_after_last no delimiter" {
  str_after_last "single" "/"
  ret=$?
  if $ret != 0
    test_pass
  else
    test_fail "should fail"
  end
}

test "str_after_last multi-char" {
  str_after_last "a::b::c" "::"
  test_equals "$R" "c"
}

test "str_after_last trailing delimiter" {
  str_after_last "trailing/" "/"
  test_equals "$R" ""
}

test "str_after_last leading delimiter" {
  str_after_last "/leading" "/"
  test_equals "$R" "leading"
}

test "str_after_last repeated" {
  str_after_last "aaa" "a"
  test_equals "$R" ""
}

test "str_before_last slash" {
  str_before_last "path/to/file" "/"
  test_equals "$R" "path/to"
}

test "str_before_last dot" {
  str_before_last "a.b.c.txt" "."
  test_equals "$R" "a.b.c"
}

test "str_before_last returns false on no match" {
  str_before_last "hello" "x"
  ret=$?
  if $ret != 0
    test_pass
  else
    test_fail "should return false"
  end
}

test "str_before_last no delimiter" {
  str_before_last "single" "/"
  ret=$?
  if $ret != 0
    test_pass
  else
    test_fail "should fail"
  end
}

test "str_before_last multi-char" {
  str_before_last "a::b::c" "::"
  test_equals "$R" "a::b"
}

test "str_before_last trailing delimiter" {
  str_before_last "trailing/" "/"
  test_equals "$R" "trailing"
}

test "str_before_last leading delimiter" {
  str_before_last "/leading" "/"
  test_equals "$R" ""
}

test "str_before_last repeated" {
  str_before_last "aaa" "a"
  test_equals "$R" "aa"
}

test "str_ltrim basic" {
  str_ltrim "  hello"
  test_equals "$R" "hello"
}

test "str_ltrim tabs" {
  str_ltrim "		tab"
  test_equals "$R" "tab"
}

test "str_ltrim mixed ws preserves trailing" {
  str_ltrim "  	 mixed  "
  test_equals "$R" "mixed  "
}

test "str_ltrim no leading ws" {
  str_ltrim "nowhitespace"
  test_equals "$R" "nowhitespace"
}

test "str_ltrim empty" {
  str_ltrim ""
  test_equals "$R" ""
}

test "str_ltrim all whitespace" {
  str_ltrim "   "
  test_equals "$R" ""
}

test "str_ltrim preserves middle and trailing" {
  str_ltrim "  hello world  "
  test_equals "$R" "hello world  "
}

test "str_ltrim newline" {
  nl_str="
line"
  str_ltrim "$nl_str"
  test_equals "$R" "line"
}

test "str_rtrim basic" {
  str_rtrim "hello  "
  test_equals "$R" "hello"
}

test "str_rtrim tabs" {
  str_rtrim "tab		"
  test_equals "$R" "tab"
}

test "str_rtrim mixed ws preserves leading" {
  str_rtrim "  mixed  	 "
  test_equals "$R" "  mixed"
}

test "str_rtrim no trailing ws" {
  str_rtrim "nowhitespace"
  test_equals "$R" "nowhitespace"
}

test "str_rtrim empty" {
  str_rtrim ""
  test_equals "$R" ""
}

test "str_rtrim all whitespace" {
  str_rtrim "   "
  test_equals "$R" ""
}

test "str_rtrim preserves middle and leading" {
  str_rtrim "  hello world  "
  test_equals "$R" "  hello world"
}

test "str_rtrim newline" {
  nl_str2="line
"
  str_rtrim "$nl_str2"
  test_equals "$R" "line"
}

test "str_trim basic" {
  str_trim "  hello  "
  test_equals "$R" "hello"
}

test "str_trim tabs" {
  str_trim "		tabs		"
  test_equals "$R" "tabs"
}

test "str_trim mixed" {
  str_trim "  	 mixed  	 "
  test_equals "$R" "mixed"
}

test "str_trim no whitespace" {
  str_trim "nowhitespace"
  test_equals "$R" "nowhitespace"
}

test "str_trim empty" {
  str_trim ""
  test_equals "$R" ""
}

test "str_trim all whitespace" {
  str_trim "   "
  test_equals "$R" ""
}

test "str_trim preserves middle" {
  str_trim "  hello world  "
  test_equals "$R" "hello world"
}

test "str_trim multiline" {
  str_trim "  multi
line  "
  test_equals "$R" "multi
line"
}

test "str_indent no indent" {
  str_indent "hello"
  test_equals "$R" ""
}

test "str_indent two spaces" {
  str_indent "  two spaces"
  test_equals "$R" "  "
}

test "str_indent four spaces" {
  str_indent "    four spaces"
  test_equals "$R" "    "
}

test "str_indent tab" {
  str_indent "	one tab"
  test_equals "$R" "	"
}

test "str_indent two tabs" {
  str_indent "		two tabs"
  test_equals "$R" "		"
}

test "str_indent mixed" {
  str_indent "  	mixed indent"
  test_equals "$R" "  	"
}

test "str_indent empty string" {
  str_indent ""
  test_equals "$R" ""
}

test "str_indent all whitespace" {
  str_indent "   "
  test_equals "$R" "   "
}

test "str_indent does not capture middle spaces" {
  str_indent "  hello world"
  test_equals "$R" "  "
}

test "str_starts dollar sign" {
  if str_starts '$PATH' '$'
    test_pass
  else
    test_fail "should match"
  end
}

test "str_ends dollar sign" {
  if str_ends 'file$' '$'
    test_pass
  else
    test_fail "should match"
  end
}

test "str_contains dollar path" {
  if str_contains '$HOME/path' '$HOME'
    test_pass
  else
    test_fail "should match"
  end
}

test "str_after with dollar in value" {
  str_after 'key=$value' '='
  test_equals "$R" '$value'
}

test "str_before with dollar in key" {
  str_before '$key=value' '='
  test_equals "$R" '$key'
}

test "str_contains backslash" {
  if str_contains 'path\\to\\file' '\\'
    test_pass
  else
    test_fail "should match"
  end
}

test "str_after backslash" {
  str_after 'C:\\Users\\file' '\\'
  test_equals "$R" 'Users\\file'
}

test "str_after_last backslash" {
  str_after_last 'C:\\Users\\file' '\\'
  test_equals "$R" "file"
}

test "str_contains single quote" {
  if str_contains "it's a test" "'"
    test_pass
  else
    test_fail "should match"
  end
}

test "str_contains double quote" {
  if str_contains 'say "hello"' '"'
    test_pass
  else
    test_fail "should match"
  end
}

test "extract filename" {
  path="/home/user/documents/file.txt"
  str_after_last "$path" "/"
  filename="$R"
  test_equals "$filename" "file.txt"
}

test "extract dirname" {
  path="/home/user/documents/file.txt"
  str_before_last "$path" "/"
  dirname="$R"
  test_equals "$dirname" "/home/user/documents"
}

test "extract extension" {
  filename="file.txt"
  str_after_last "$filename" "."
  ext="$R"
  test_equals "$ext" "txt"
}

test "extract basename" {
  filename="file.txt"
  str_before_last "$filename" "."
  base="$R"
  test_equals "$base" "file"
}

test "url host" {
  url="https://example.com:8080/path/to/page?query=1"
  str_after "$url" "://"
  rest="$R"
  str_before "$rest" "/"
  host_port="$R"
  str_before "$host_port" ":"
  host="$R"
  test_equals "$host" "example.com"
}

test "url port" {
  url="https://example.com:8080/path/to/page?query=1"
  str_after "$url" "://"
  rest="$R"
  str_before "$rest" "/"
  host_port="$R"
  str_after "$host_port" ":"
  port="$R"
  test_equals "$port" "8080"
}

test "str_after repeated delim" {
  str_after "a///b" "/"
  test_equals "$R" "//b"
}

test "str_after_last repeated delim" {
  str_after_last "a///b" "/"
  test_equals "$R" "b"
}

test "str_before repeated delim" {
  str_before "a///b" "/"
  test_equals "$R" "a"
}

test "str_before_last repeated delim" {
  str_before_last "a///b" "/"
  test_equals "$R" "a//"
}

test "str_ends long string" {
  long_str="aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaX"
  if str_ends "$long_str" "X"
    test_pass
  else
    test_fail "should match"
  end
}

test "str_starts long string" {
  long_str="aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaX"
  if str_starts "$long_str" "aaaa"
    test_pass
  else
    test_fail "should match"
  end
}


test "str_contains extended ascii" {
  if str_contains "caf" "f"
    test_pass
  else
    test_fail "should match"
  end
}

echo
echo "=== scan ==="

test "scan empty pattern empty input" {
  scan "" ""
  ret=$?
  if $ret == 0
    test_pass
  else
    test_fail "should match"
  end
}

test "scan empty pattern non-empty input" {
  scan "x" ""
  ret=$?
  if $ret == 0
    test_pass
  else
    test_fail "should match"
  end
}

test "scan literal exact" {
  scan "hello" "hello"
  ret=$?
  if $ret == 0
    test_pass
  else
    test_fail "should match"
  end
}

test "scan literal mismatch" {
  scan "hello" "hellx"
  ret=$?
  if $ret != 0
    test_pass
  else
    test_fail "should not match"
  end
}

test "scan literal prefix match" {
  scan "hello" "he"
  ret=$?
  if $ret == 0
    test_pass
  else
    test_fail "should match"
  end
}

test "scan single capture whole input" {
  v=""
  scan "abc" "%v"
  ret=$?
  if $ret != 0
    test_fail "should match"
  else
    test_equals "$v" "abc"
  end
}

test "scan prefix then capture" {
  name=""
  scan "hi bob" "hi %name"
  ret=$?
  if $ret != 0
    test_fail "should match"
  else
    test_equals "$name" "bob"
  end
}

test "scan capture then suffix" {
  who=""
  scan "bob!" "%who!"
  ret=$?
  if $ret != 0
    test_fail "should match"
  else
    test_equals "$who" "bob"
  end
}

test "scan two captures with delimiters" {
  x="" y=""
  scan "a=1;b=2" "a=%x;b=%y"
  ret=$?
  if $ret != 0
    test_fail "should match"
  else
    test_equals "$x" "1"
  end
}

test "scan two captures y" {
  test_equals "$y" "2"
}

test "scan empty capture allowed" {
  x="" y=""
  scan "a=;b=2" "a=%x;b=%y"
  ret=$?
  if $ret != 0
    test_fail "should match"
  else
    test_equals "$x" ""
  end
}

test "scan empty capture allowed y" {
  test_equals "$y" "2"
}

test "scan delimiter missing fails" {
  scan "a=1;b=2" "a=%x;c=%y"
  ret=$?
  if $ret != 0
    test_pass
  else
    test_fail "should not match"
  end
}

test "scan invalid var name fails" {
  scan "x" "%1bad"
  ret=$?
  if $ret != 0
    test_pass
  else
    test_fail "should not match"
  end
}

test "scan lone percent fails" {
  scan "x" "%"
  ret=$?
  if $ret != 0
    test_pass
  else
    test_fail "should not match"
  end
}

test "scan consecutive captures edge" {
  a="" b=""
  scan "abc" "%a%b"
  ret=$?
  if $ret != 0
    test_fail "should match"
  else
    test_equals "$a" ""
  end
}

test "scan consecutive captures edge b" {
  test_equals "$b" "abc"
}

test "scan pattern allows trailing input" {
  v=""
  scan "a=1;tail" "a=%v"
  ret=$?
  if $ret != 0
    test_fail "should match"
  else
    test_equals "$v" "1;tail"
  end
}

test "scan trailing literal still allows extra input" {
  v=""
  scan "a=1!EXTRA" "a=%v!"
  ret=$?
  if $ret != 0
    test_fail "should match"
  else
    test_equals "$v" "1"
  end
}

test "scan empty capture at beginning" {
  v=""
  scan ":x" "%v:x"
  ret=$?
  if $ret != 0
    test_fail "should match"
  else
    test_equals "$v" ""
  end
}

test "scan empty capture at end" {
  v=""
  scan "x:" "x:%v"
  ret=$?
  if $ret != 0
    test_fail "should match"
  else
    test_equals "$v" ""
  end
}

test "scan repeated delimiters makes empty field" {
  a="" b=""
  scan "a==b" "a=%a=%b"
  ret=$?
  if $ret != 0
    test_fail "should match"
  else
    test_equals "$a" ""
  end
}

test "scan repeated delimiters b" {
  test_equals "$b" "b"
}

test "scan duplicate var name last wins" {
  x=""
  scan "a=1,b=2" "a=%x,b=%x"
  ret=$?
  if $ret != 0
    test_fail "should match"
  else
    test_equals "$x" "2"
  end
}

test "scan underscore-leading var name" {
  _v=""
  scan "k=ok" "k=%_v"
  ret=$?
  if $ret != 0
    test_fail "should match"
  else
    test_equals "$_v" "ok"
  end
}

test "scan var name with digits" {
  v9=""
  scan "k=ok" "k=%v9"
  ret=$?
  if $ret != 0
    test_fail "should match"
  else
    test_equals "$v9" "ok"
  end
}

test "scan rejects var name with dash" {
  scan "k=ok" "k=%bad-name"
  ret=$?
  if $ret != 0
    test_pass
  else
    test_fail "should not match"
  end
}

test "scan captures spaces" {
  msg=""
  scan "say hello world!" "say %msg!"
  ret=$?
  if $ret != 0
    test_fail "should match"
  else
    test_equals "$msg" "hello world"
  end
}

test "scan captures glob chars literally" {
  g=""
  scan "x=*?[abc]" "x=%g"
  ret=$?
  if $ret != 0
    test_fail "should match"
  else
    test_equals "$g" "*?[abc]"
  end
}

test "scan captures dollar sign literally" {
  d=""
  scan "p=\$HOME" "p=%d"
  ret=$?
  if $ret != 0
    test_fail "should match"
  else
    test_equals "$d" '$HOME'
  end
}

test "scan captures backslash literally" {
  bsl=""
  scan "p=C:\\Windows" "p=%bsl"
  ret=$?
  if $ret != 0
    test_fail "should match"
  else
    test_equals "$bsl" "C:\\Windows"
  end
}

test "scan captures single quote" {
  q=""
  scan "q=it's" "q=%q"
  ret=$?
  if $ret != 0
    test_fail "should match"
  else
    test_equals "$q" "it's"
  end
}

test "scan captures double quote" {
  dq=""
  scan "q=\"hi\"" "q=%dq"
  ret=$?
  if $ret != 0
    test_fail "should match"
  else
    test_equals "$dq" "\"hi\""
  end
}

test "scan unicode capture" {
  u=""
  scan "caf=au lait" "caf=%u"
  ret=$?
  if $ret != 0
    test_fail "should match"
  else
    test_equals "$u" "au lait"
  end
}

test "scan fails when required literal not at start" {
  scan "xxHELLO" "HELLO"
  ret=$?
  if $ret != 0
    test_pass
  else
    test_fail "should not match"
  end
}

test "scan cannot match literal percent" {
  scan "100%" "100%"
  ret=$?
  if $ret != 0
    test_pass
  else
    test_fail "should not match"
  end
}

test "scan percent at end fails" {
  scan "x" "x%"
  ret=$?
  if $ret != 0
    test_pass
  else
    test_fail "should not match"
  end
}

echo
echo "=== Nested Blocks ==="

test "if inside switch" {
  _nb_result=""
  _nb_cmd="start"
  _nb_verbose=1
  switch $_nb_cmd
  case start
    if $_nb_verbose == 1
      _nb_result="verbose_start"
    else
      _nb_result="quiet_start"
    end
  case stop: _nb_result="stop"
  end
  test_equals "$_nb_result" "verbose_start"
}

test "if/elif/else inside switch" {
  _nb2_result=""
  _nb2_level="debug"
  _nb2_trace=0
  _nb2_debug=1
  switch $_nb2_level
  case debug
    if $_nb2_trace == 1
      _nb2_result="trace"
    elif $_nb2_debug == 1
      _nb2_result="debug"
    else
      _nb2_result="other"
    end
  case info: _nb2_result="info"
  end
  test_equals "$_nb2_result" "debug"
}

test "multiple ifs in switch (a)" {
  _nb3_a=""
  _nb3_b=""
  _nb3_mode="both"
  switch $_nb3_mode
  case both
    if 1 == 1
      _nb3_a="first"
    end
    if 2 == 2
      _nb3_b="second"
    end
  case neither: _nb3_a="none"
  end
  test_equals "$_nb3_a" "first"
}

test "multiple ifs in switch (b)" {
  test_equals "$_nb3_b" "second"
}

test "switch inside if" {
  _nb4_result=""
  _nb4_enabled=1
  _nb4_type="foo"
  if $_nb4_enabled == 1
    switch $_nb4_type
    case foo: _nb4_result="enabled_foo"
    case bar: _nb4_result="enabled_bar"
    end
  end
  test_equals "$_nb4_result" "enabled_foo"
}

test "if>switch>if nesting" {
  _nb5_result=""
  _nb5_outer=1
  _nb5_sel="a"
  _nb5_inner=1
  if $_nb5_outer == 1
    switch $_nb5_sel
    case a
      if $_nb5_inner == 1
        _nb5_result="deep_a_inner"
      else
        _nb5_result="deep_a_outer"
      end
    case b
      _nb5_result="deep_b"
    end
  end
  test_equals "$_nb5_result" "deep_a_inner"
}

test "switch inside switch" {
  _nb6_result=""
  _nb6_outer="x"
  _nb6_inner="y"
  switch $_nb6_outer
  case x
    switch $_nb6_inner
    case y: _nb6_result="x_y"
    case z: _nb6_result="x_z"
    end
  case w: _nb6_result="w"
  end
  test_equals "$_nb6_result" "x_y"
}

test "if>switch>switch nesting" {
  _nb7_result=""
  _nb7_a="p"
  _nb7_b="q"
  _nb7_c=1
  switch $_nb7_a
  case p
    switch $_nb7_b
    case q
      if $_nb7_c == 1
        _nb7_result="p_q_true"
      else
        _nb7_result="p_q_false"
      end
    end
  end
  test_equals "$_nb7_result" "p_q_true"
}

test "while inside switch" {
  _nb8_result=0
  _nb8_mode="loop"
  _nb8_count=3
  switch $_nb8_mode
  case loop
    while $_nb8_count > 0
      _nb8_result=$((_nb8_result + 1))
      _nb8_count=$((_nb8_count - 1))
    done
  case single: _nb8_result=999
  end
  test_equals "$_nb8_result" "3"
}

test "for inside switch" {
  _nb9_result=""
  _nb9_mode="iterate"
  switch $_nb9_mode
  case iterate
    for _nb9_i in a b c
      _nb9_result="${_nb9_result}${_nb9_i}"
    done
  case skip: _nb9_result="skipped"
  end
  test_equals "$_nb9_result" "abc"
}

test "if>while inside switch" {
  _nb10_result=0
  _nb10_mode="conditional_loop"
  _nb10_enabled=1
  _nb10_n=2
  switch $_nb10_mode
  case conditional_loop
    if $_nb10_enabled == 1
      while $_nb10_n > 0
        _nb10_result=$((_nb10_result + 1))
        _nb10_n=$((_nb10_n - 1))
      done
    end
  end
  test_equals "$_nb10_result" "2"
}

test "if>switch>if>switch" {
  _nb11_result=""
  _nb11_a=1
  _nb11_b="x"
  _nb11_c=1
  _nb11_d="y"
  if $_nb11_a == 1
    switch $_nb11_b
    case x
      if $_nb11_c == 1
        switch $_nb11_d
        case y
          _nb11_result="a1_bx_c1_dy"
        end
      end
    end
  end
  test_equals "$_nb11_result" "a1_bx_c1_dy"
}

test "single-line if then outer else" {
  _nb12_result=""
  _nb12_outer=1
  _nb12_inner=0
  if $_nb12_outer == 1
    if $_nb12_inner == 1
      _nb12_result="inner_true"
    end
  else
    _nb12_result="outer_false"
  end
  test_equals "$_nb12_result" ""
}

test "single-line if, outer else taken" {
  _nb13_result=""
  _nb13_outer=0
  _nb13_inner=1
  if $_nb13_outer == 1
    if $_nb13_inner == 1
      _nb13_result="inner_true"
    end
  else
    _nb13_result="outer_false"
  end
  test_equals "$_nb13_result" "outer_false"
}

rm -f /tmp/shsh_test.txt /tmp/shsh_test2.txt /tmp/shsh_empty.txt /tmp/shsh_special.txt /tmp/shsh_fmt.txt

echo
echo "=== Try/Catch ==="

test "try/catch basic" {
  _tc_basic=""
  try
    _tc_basic="${_tc_basic}A"
    false
    _tc_basic="${_tc_basic}B"
  catch
    _tc_basic="${_tc_basic}C"
  end
  _tc_basic="${_tc_basic}D"
  test_equals "$_tc_basic" "ACD"
}

test "try/catch no error" {
  _tc_noerr=""
  try
    _tc_noerr="${_tc_noerr}A"
    true
    _tc_noerr="${_tc_noerr}B"
  catch
    _tc_noerr="${_tc_noerr}C"
  end
  _tc_noerr="${_tc_noerr}D"
  test_equals "$_tc_noerr" "ABD"
}

test "try without catch" {
  _tc_nocatch=""
  try
    _tc_nocatch="${_tc_nocatch}A"
    false
    _tc_nocatch="${_tc_nocatch}B"
  end
  _tc_nocatch="${_tc_nocatch}C"
  test_equals "$_tc_nocatch" "AC"
}

test "try without catch no error" {
  _tc_nocatch2=""
  try
    _tc_nocatch2="${_tc_nocatch2}A"
    true
    _tc_nocatch2="${_tc_nocatch2}B"
  end
  _tc_nocatch2="${_tc_nocatch2}C"
  test_equals "$_tc_nocatch2" "ABC"
}

test "nested try/catch inner" {
  _tc_nest1=""
  try
    _tc_nest1="${_tc_nest1}A"
    try
      _tc_nest1="${_tc_nest1}B"
      false
      _tc_nest1="${_tc_nest1}C"
    catch
      _tc_nest1="${_tc_nest1}D"
    end
    _tc_nest1="${_tc_nest1}E"
  catch
    _tc_nest1="${_tc_nest1}F"
  end
  _tc_nest1="${_tc_nest1}G"
  test_equals "$_tc_nest1" "ABDEG"
}

test "nested try/catch outer" {
  _tc_nest2=""
  try
    _tc_nest2="${_tc_nest2}A"
    try
      _tc_nest2="${_tc_nest2}B"
    catch
      _tc_nest2="${_tc_nest2}C"
    end
    _tc_nest2="${_tc_nest2}D"
    false
    _tc_nest2="${_tc_nest2}E"
  catch
    _tc_nest2="${_tc_nest2}F"
  end
  _tc_nest2="${_tc_nest2}G"
  test_equals "$_tc_nest2" "ABDFG"
}

test "try/catch exit code" {
  _tc_exit=""
  try
    _tc_exit="${_tc_exit}A"
    sh -c 'exit 5'
    _tc_exit="${_tc_exit}B"
  catch
    _tc_exit="${_tc_exit}C"
  end
  test_equals "$_tc_exit" "AC"
}

test "try/catch pipeline success" {
  _tc_pipe=""
  try
    _tc_pipe="${_tc_pipe}A"
    echo "test" | grep "test" > /dev/null
    _tc_pipe="${_tc_pipe}B"
  catch
    _tc_pipe="${_tc_pipe}C"
  end
  test_equals "$_tc_pipe" "AB"
}

test "try/catch multi statements" {
  _tc_multi=""
  try
    _tc_multi="${_tc_multi}A"
    _tc_multi="${_tc_multi}B"
    _tc_multi="${_tc_multi}C"
    false
    _tc_multi="${_tc_multi}D"
  catch
    _tc_multi="${_tc_multi}E"
  end
  test_equals "$_tc_multi" "ABCE"
}

test "try/catch inside if" {
  _tc_inif=""
  if true
    try
      _tc_inif="${_tc_inif}A"
      false
      _tc_inif="${_tc_inif}B"
    catch
      _tc_inif="${_tc_inif}C"
    end
  end
  test_equals "$_tc_inif" "AC"
}

test "try/catch inside while" {
  _tc_inwhile=""
  _tc_count=0
  while $_tc_count < 2
    try
      _tc_inwhile="${_tc_inwhile}A"
      if $_tc_count == 0: false
      _tc_inwhile="${_tc_inwhile}B"
    catch
      _tc_inwhile="${_tc_inwhile}C"
    end
    _tc_count++
  done
  test_equals "$_tc_inwhile" "ACAB"
}

test "if inside try" {
  _tc_ifinside=""
  try
    _tc_ifinside="${_tc_ifinside}A"
    if true
      _tc_ifinside="${_tc_ifinside}B"
      false
      _tc_ifinside="${_tc_ifinside}C"
    end
    _tc_ifinside="${_tc_ifinside}D"
  catch
    _tc_ifinside="${_tc_ifinside}E"
  end
  test_equals "$_tc_ifinside" "ABE"
}

test "while inside try" {
  _tc_whileinside=""
  try
    _tc_whileinside="${_tc_whileinside}A"
    _tc_wi=0
    while $_tc_wi < 3
      _tc_whileinside="${_tc_whileinside}B"
      _tc_wi++
      if $_tc_wi == 2: false
    done
    _tc_whileinside="${_tc_whileinside}C"
  catch
    _tc_whileinside="${_tc_whileinside}D"
  end
  test_equals "$_tc_whileinside" "ABBD"
}

test "triple nested try" {
  _tc_triple=""
  try
    _tc_triple="${_tc_triple}A"
    try
      _tc_triple="${_tc_triple}B"
      try
        _tc_triple="${_tc_triple}C"
        false
        _tc_triple="${_tc_triple}D"
      catch
        _tc_triple="${_tc_triple}E"
      end
      _tc_triple="${_tc_triple}F"
    catch
      _tc_triple="${_tc_triple}G"
    end
    _tc_triple="${_tc_triple}H"
  catch
    _tc_triple="${_tc_triple}I"
  end
  test_equals "$_tc_triple" "ABCEFH"
}

test "catch with logic" {
  _tc_catchlogic=""
  try
    false
  catch
    if true
      _tc_catchlogic="caught"
    end
  end
  test_equals "$_tc_catchlogic" "caught"
}

test "try variable scope" {
  _tc_varscope=""
  try
    _tc_varscope="set"
  catch
    _tc_varscope="error"
  end
  test_equals "$_tc_varscope" "set"
}

test "error code captured" {
  try
    sh -c 'exit 42'
  catch
    _tc_errcode="$error"
  end
  test_equals "$_tc_errcode" "42"
}

test "string truthy" {
  my_str="hello"
  try
    if $my_str
      test_pass
    else
      test_fail "string truthy"
    end
  catch
    test_fail "Shell tried to execute string"
  end
}

test "string false truthy" {
  my_val="false"
  if $my_val
    test_pass
  else
    test_fail "string 'false' truthy"
  end
}

test "empty string truthy" {
  empty=""
  try
    if $empty
      test_fail "empty string truthy"
    else
      test_pass
    end
  catch
    test_fail "empty string truthy"
  end
}

echo
echo "=== Truthy Variable Edge Cases ==="

test "braced var truthy" {
  _brace_var="value"
  if ${_brace_var}
    test_pass
  else
    test_fail "braced var truthy"
  end
}

test "braced empty var falsy" {
  _brace_empty=""
  if ${_brace_empty}
    test_fail "braced empty var falsy"
  else
    test_pass
  end
}

test "numeric 0 is truthy (non-empty string)" {
  _num_zero=0
  if $_num_zero
    test_pass
  else
    test_fail "numeric 0 is truthy (non-empty string)"
  end
}

test "numeric 1 truthy" {
  _num_one=1
  if $_num_one
    test_pass
  else
    test_fail "numeric 1 truthy"
  end
}

test "whitespace string truthy" {
  _whitespace="   "
  if $_whitespace
    test_pass
  else
    test_fail "whitespace string truthy"
  end
}

test "string with space truthy" {
  _special="hello world"
  if $_special
    test_pass
  else
    test_fail "string with space truthy"
  end
}

test "string with glob chars truthy" {
  _special2="a*b?c[d]"
  if $_special2
    test_pass
  else
    test_fail "string with glob chars truthy"
  end
}

test "underscore prefix var truthy" {
  _underscore_var="yes"
  if $_underscore_var
    test_pass
  else
    test_fail "underscore prefix var truthy"
  end
}

test "var with numbers truthy" {
  var123="numeric name"
  if $var123
    test_pass
  else
    test_fail "var with numbers truthy"
  end
}

test "command true works" {
  if true
    test_pass
  else
    test_fail "command 'true' works"
  end
}

test "command false works" {
  if false
    test_fail "command 'false' works"
  else
    test_pass
  end
}

_test_func() { return 0; }

test "function call works" {
  if _test_func
    test_pass
  else
    test_fail "function call works"
  end
}

test "test command works" {
  if test -n "hello"
    test_pass
  else
    test_fail "test command works"
  end
}

test "negated truthy var" {
  _neg_var="something"
  if ! $_neg_var
    test_fail "negated truthy var"
  else
    test_pass
  end
}

test "negated empty var" {
  _neg_empty=""
  if ! $_neg_empty
    test_pass
  else
    test_fail "negated empty var"
  end
}

test "comparison with quoted vars" {
  _cmp_a="foo"
  _cmp_b="foo"
  if "$_cmp_a" == "$_cmp_b"
    test_pass
  else
    test_fail "comparison with quoted vars"
  end
}

test "while truthy var loop" {
  _while_cond="go"
  _while_count=0
  while $_while_cond
    _while_count=$((_while_count + 1))
    if $_while_count >= 3: _while_cond=""
  done
  test_equals "$_while_count" "3"
}

test "elif truthy var" {
  _elif_val=""
  _elif_other="yes"
  if $_elif_val
    _elif_result="first"
  elif $_elif_other
    _elif_result="second"
  else
    _elif_result="third"
  end
  test_equals "$_elif_result" "second"
}

echo
echo "=== Security / Red Team Tests ==="

test "cmd substitution not wrapped" {
  _cmd_sub_result=""
  try
    if $(echo true)
      _cmd_sub_result="executed"
    end
  catch
    _cmd_sub_result="error"
  end
  test_equals "$_cmd_sub_result" "executed"
}

test "backtick not wrapped" {
  _backtick_result=""
  try
    if `echo true`
      _backtick_result="executed"
    end
  catch
    _backtick_result="error"
  end
  test_equals "$_backtick_result" "executed"
}

test "simple var no injection" {
  _inj1="val"
  _inj1_result=""
  try
    if $_inj1
      _inj1_result="ok"
    end
  catch
    _inj1_result="error"
  end
  test_equals "$_inj1_result" "ok"
}

test "! false works" {
  _not_cmd=""
  if ! false
    _not_cmd="ok"
  end
  test_equals "$_not_cmd" "ok"
}

test "! true works" {
  if ! true
    _not_true="yes"
  else
    _not_true="no"
  end
  test_equals "$_not_true" "no"
}

test "! test -z works" {
  if ! test -z "hello"
    _not_test="not empty"
  else
    _not_test="empty"
  end
  test_equals "$_not_test" "not empty"
}

_false_func() { return 1; }

test "! function works" {
  if ! _false_func
    _not_func="ok"
  else
    _not_func="fail"
  end
  test_equals "$_not_func" "ok"
}

test "positional \$1 truthy" {
  set -- "arg1" "arg2"
  if $1
    _pos_result="truthy"
  else
    _pos_result="falsy"
  end
  test_equals "$_pos_result" "truthy"
}

test "\$# not wrapped as simple var" {
  _argc_pass=0
  try
    if $# >/dev/null 2>&1
      _argc_pass=1
    else
      _argc_pass=1
    end
  catch
    _argc_pass=1
  end
  test_equals "$_argc_pass" "1"
}

test "\$? not wrapped as simple var" {
  _status_pass=0
  try
    if $? >/dev/null 2>&1
      _status_pass=1
    else
      _status_pass=1
    end
  catch
    _status_pass=1
  end
  test_equals "$_status_pass" "1"
}

test "\$\$ not wrapped as simple var" {
  _pid_pass=0
  try
    if $$ >/dev/null 2>&1
      _pid_pass=1
    else
      _pid_pass=1
    end
  catch
    _pid_pass=1
  end
  test_equals "$_pid_pass" "1"
}

test "\$! not wrapped as simple var" {
  _bg_pass=0
  try
    if $! 2>/dev/null
      _bg_pass=1
    else
      _bg_pass=1
    end
  catch
    _bg_pass=1
  end
  test_equals "$_bg_pass" "1"
}

test "bare \$ not wrapped as simple var" {
  _bare_pass=0
  try
    if $ 2>/dev/null
      _bare_pass=1
    else
      _bare_pass=1
    end
  catch
    _bare_pass=1
  end
  test_equals "$_bare_pass" "1"
}

test "empty \${} is shell syntax error (expected)" {
  test_pass
}

test "long var name works" {
  _verylongvariablenamethatisquitelongindeed="yes"
  if $_verylongvariablenamethatisquitelongindeed
    test_pass
  else
    test_fail "long var name works"
  end
}

test "\${var:-x} not wrapped as simple var" {
  _complex_var=""
  _complex_pass=0
  try
    if ${_complex_var:-shouldfail} 2>/dev/null
      _complex_pass=0
    else
      _complex_pass=1
    end
  catch
    _complex_pass=1
  end
  test_equals "$_complex_pass" "1"
}

test "\${#var} not wrapped as simple var" {
  _len_test="hello"
  _len_pass=0
  try
    if ${#_len_test} 2>/dev/null
      _len_pass=0
    else
      _len_pass=1
    end
  catch
    _len_pass=1
  end
  test_equals "$_len_pass" "1"
}

test "\${var:+x} not wrapped as simple var" {
  _alt_test="set"
  _alt_pass=0
  try
    if ${_alt_test:+shouldfail} 2>/dev/null
      _alt_pass=0
    else
      _alt_pass=1
    end
  catch
    _alt_pass=1
  end
  test_equals "$_alt_pass" "1"
}

test "\$1abc not wrapped as simple var" {
  set -- ""
  _num_pass=0
  try
    if $1abc 2>/dev/null
      _num_pass=0
    else
      _num_pass=1
    end
  catch
    _num_pass=1
  end
  test_equals "$_num_pass" "1"
}

test "\$\$var not wrapped as simple var" {
  _nested_pass=0
  try
    if $$_nested 2>/dev/null
      _nested_pass=0
    else
      _nested_pass=1
    end
  catch
    _nested_pass=1
  end
  test_equals "$_nested_pass" "1"
}

echo
echo "=== file_hash ==="

FH_F1="shsh_test_file_hash_1_$$"
FH_F2="shsh_test_file_hash_2_$$"

printf 'hello\n' > "$FH_F1" || {
  test_fail "file_hash: setup failed (FH_F1)"
  exit 1
}

test "file_hash: missing file fails" {
  if file_hash "shsh_no_such_file_$$"
    test_fail "file_hash: missing file should fail"
  else
    test_pass
  end
}

test "file_hash: non-empty hash" {
  if file_hash "$FH_F1"
    FH_HASH1="$R"
    if test -n "$FH_HASH1"
      test_pass
    else
      test_fail "file_hash: hash is empty"
    end
  else
    test_fail "file_hash: returns non-zero on existing file"
  end
}

cp "$FH_F1" "$FH_F2" || {
  test_fail "file_hash: setup failed (FH_F2 copy)"
}

test "file_hash: identical files share hash" {
  if file_hash "$FH_F2"
    FH_HASH2="$R"
    if "$FH_HASH1" == "$FH_HASH2"
      test_pass
    else
      test_fail "file_hash: identical files have different hash"
    end
  else
    test_fail "file_hash: second file hash call failed"
  end
}

printf 'world\n' > "$FH_F2" || {
  test_fail "file_hash: setup failed (FH_F2 overwrite)"
}

test "file_hash: different files differ" {
  if file_hash "$FH_F2"
    FH_HASH3="$R"
    if "$FH_HASH1" != "$FH_HASH3"
      test_pass
    else
      test_fail "file_hash: different files share hash"
    end
  else
    test_fail "file_hash: different-content hash call failed"
  end
}

test "file_hash: matches system hash" {
  if command -v sha256sum >/dev/null 2>&1
    REF_HASH=$(sha256sum "$FH_F1" | awk '{print $1}')
    if "$REF_HASH" == "$FH_HASH1"
      test_pass
    else
      test_fail "file_hash: mismatch vs sha256sum"
    end
  elif command -v shasum >/dev/null 2>&1
    REF_HASH=$(shasum -a 256 "$FH_F1" | awk '{print $1}')
    if "$REF_HASH" == "$FH_HASH1"
      test_pass
    else
      test_fail "file_hash: mismatch vs shasum -a 256"
    end
  elif command -v md5sum >/dev/null 2>&1
    REF_HASH=$(md5sum "$FH_F1" | awk '{print $1}')
    if "$REF_HASH" == "$FH_HASH1"
      test_pass
    else
      test_fail "file_hash: mismatch vs md5sum"
    end
  elif command -v cksum >/dev/null 2>&1
    set -- $(cksum "$FH_F1")
    REF_CRC="$1"
    REF_HASH=$(printf '%x' "$REF_CRC")
    if "$REF_HASH" == "$FH_HASH1"
      test_pass
    else
      test_fail "file_hash: mismatch vs cksum-based hash"
    end
  else
    test_pass
  end
}

rm -f "$FH_F1" "$FH_F2"

echo
echo "=== Script Argument Passing ==="

printf 'printf "%%s\\n" "$@"\n' > /tmp/shsh_args_test.shsh

test "single arg passed" {
  _args_out="$(sh "$_shsh" /tmp/shsh_args_test.shsh one)"
  test_equals "$_args_out" "one"
}

test "multi args passed" {
  _args_out="$(sh "$_shsh" /tmp/shsh_args_test.shsh one two three | tr '\n' ',')"
  test_equals "$_args_out" "one,two,three,"
}

test "arg with space" {
  _args_out="$(sh "$_shsh" /tmp/shsh_args_test.shsh "hello world")"
  test_equals "$_args_out" "hello world"
}

test "no args (empty)" {
  _args_out="$(sh "$_shsh" /tmp/shsh_args_test.shsh)"
  test_equals "$_args_out" ""
}

test "arg count 5" {
  printf 'printf "count:%%s\\n" "$#"\n' > /tmp/shsh_argc_test.shsh
  _argc_out="$(sh "$_shsh" /tmp/shsh_argc_test.shsh a b c d e)"
  test_equals "$_argc_out" "count:5"
}

test "positional args \$1 \$2" {
  printf 'printf "first:%%s second:%%s\\n" "$1" "$2"\n' > /tmp/shsh_posarg_test.shsh
  _posarg_out="$(sh "$_shsh" /tmp/shsh_posarg_test.shsh alpha beta gamma)"
  test_equals "$_posarg_out" "first:alpha second:beta"
}

rm -f /tmp/shsh_args_test.shsh /tmp/shsh_argc_test.shsh /tmp/shsh_posarg_test.shsh

echo
echo "=== Compiler Output Validation ==="

test "switch compilation produces valid shell" {
  cat > /tmp/shsh_switch_compile.shsh << 'SHSH'
switch $x
  case a: echo a
  case b: echo b
end
SHSH
  _compiled="$(sh "$_shsh" raw /tmp/shsh_switch_compile.shsh)"
  if sh -n -c "$_compiled" 2>/dev/null
    test_pass
  else
    test_fail "invalid shell"
  end
}

test "nested switch compilation produces valid shell" {
  cat > /tmp/shsh_nested_switch.shsh << 'SHSH'
switch $outer
  case a
    switch $inner
      case x: echo ax
      case y: echo ay
    end
  case b: echo b
end
SHSH
  _compiled="$(sh "$_shsh" raw /tmp/shsh_nested_switch.shsh)"
  if sh -n -c "$_compiled" 2>/dev/null
    test_pass
  else
    test_fail "invalid shell"
  end
}

test "3-level nested switch compilation valid" {
  cat > /tmp/shsh_3level_switch.shsh << 'SHSH'
switch $a
  case 1
    switch $b
      case x
        switch $c
          case p: echo 1xp
          case q: echo 1xq
        end
      case y: echo 1y
    end
  case 2: echo 2
end
SHSH
  _compiled="$(sh "$_shsh" raw /tmp/shsh_3level_switch.shsh)"
  if sh -n -c "$_compiled" 2>/dev/null
    test_pass
  else
    test_fail "invalid shell"
  end
}

test "switch with default compilation valid" {
  cat > /tmp/shsh_switch_default.shsh << 'SHSH'
switch $x
  case a: echo a
  default: echo other
end
SHSH
  _compiled="$(sh "$_shsh" raw /tmp/shsh_switch_default.shsh)"
  if sh -n -c "$_compiled" 2>/dev/null
    test_pass
  else
    test_fail "invalid shell"
  end
}

test "switch inside if compilation valid" {
  cat > /tmp/shsh_switch_in_if.shsh << 'SHSH'
if $cond == 1
  switch $x
    case a: echo a
    case b: echo b
  end
end
SHSH
  _compiled="$(sh "$_shsh" raw /tmp/shsh_switch_in_if.shsh)"
  if sh -n -c "$_compiled" 2>/dev/null
    test_pass
  else
    test_fail "invalid shell"
  end
}

test "single-line while compilation valid" {
  cat > /tmp/shsh_while_colon.shsh << 'SHSH'
i=0
while $i < 3: i=$((i + 1))
echo done
SHSH
  _compiled="$(sh "$_shsh" raw /tmp/shsh_while_colon.shsh)"
  if sh -n -c "$_compiled" 2>/dev/null
    test_pass
  else
    test_fail "invalid shell"
  end
}

test "compiled switch runs correctly" {
  cat > /tmp/shsh_switch_run.shsh << 'SHSH'
result=""
for x in a b c
  switch $x
    case a: result="${result}A"
    case b: result="${result}B"
    default: result="${result}X"
  end
done
echo "$result"
SHSH
  _run_out="$(sh "$_shsh" /tmp/shsh_switch_run.shsh)"
  test_equals "$_run_out" "ABX"
}

test "nested switch runs correctly" {
  cat > /tmp/shsh_nested_run.shsh << 'SHSH'
result=""
for o in a b
  for i in x y
    switch $o
      case a
        switch $i
          case x: result="${result}ax"
          case y: result="${result}ay"
        end
      case b: result="${result}b"
    end
  done
done
echo "$result"
SHSH
  _nested_out="$(sh "$_shsh" /tmp/shsh_nested_run.shsh)"
  test_equals "$_nested_out" "axaybb"
}

test "bootstrap produces stable output" {
  sh "$_shsh" raw $_shsh_src > /tmp/shsh_boot1.sh
  chmod +x /tmp/shsh_boot1.sh
  sh /tmp/shsh_boot1.sh raw $_shsh_src > /tmp/shsh_boot2.sh
  if diff -q /tmp/shsh_boot1.sh /tmp/shsh_boot2.sh >/dev/null 2>&1
    test_pass
  else
    test_fail "different output on second compile"
  end
}

test "build strips unused runtime functions" {
  cat > /tmp/shsh_strip_test.shsh << 'SHSH'
echo "simple"
SHSH
  _strip_out="$(sh "$_shsh" build /tmp/shsh_strip_test.shsh)"
  _full_out="$(sh "$_shsh" build_full /tmp/shsh_strip_test.shsh)"
  _strip_lines="$(printf '%s\n' "$_strip_out" | wc -l)"
  _full_lines="$(printf '%s\n' "$_full_out" | wc -l)"
  if $_strip_lines < $_full_lines
    test_pass
  else
    test_fail "build should produce smaller output than build_full"
  end
}

test "stripped script runs correctly" {
  cat > /tmp/shsh_strip_run.shsh << 'SHSH'
array_add items "a"
array_add items "b"
array_len items
echo "$R"
SHSH
  sh "$_shsh" build /tmp/shsh_strip_run.shsh > /tmp/shsh_strip_run.sh
  _strip_run_out="$(sh /tmp/shsh_strip_run.sh)"
  test_equals "$_strip_run_out" "2"
}

rm -f /tmp/shsh_switch_compile.shsh /tmp/shsh_nested_switch.shsh /tmp/shsh_3level_switch.shsh
rm -f /tmp/shsh_switch_default.shsh /tmp/shsh_switch_in_if.shsh /tmp/shsh_while_colon.shsh
rm -f /tmp/shsh_switch_run.shsh /tmp/shsh_nested_run.shsh /tmp/shsh_boot1.sh /tmp/shsh_boot2.sh
rm -f /tmp/shsh_strip_test.shsh /tmp/shsh_strip_run.shsh /tmp/shsh_strip_run.sh

echo
echo "=== Tree Shaking ==="

test "tree shake: no runtime markers" {
  _ts_out=$("$_shsh" build <<'SHSH'
echo "hello"
SHSH
)
  if str_contains "$_ts_out" "__RUNTIME_START__"
    test_fail "should not contain runtime markers"
  else
    test_pass
  end
}

test "tree shake: pure shell no runtime" {
  _ts_pure=$("$_shsh" build <<'SHSH'
x=1
echo $x
SHSH
)
  # Build expected output - must use printf to avoid shsh parsing the shell code
  _ts_line1='#!/bin/sh'
  _ts_line2='if [ -z "$_SHSH_DASH" ] && command -v dash >/dev/null 2>&1; then export _SHSH_DASH=1; exec dash "$0" "$@"; fi'
  _ts_line3='x=1'
  _ts_line4='echo $x'
  _ts_expected=$(printf '%s\n%s\n%s\n%s' "$_ts_line1" "$_ts_line2" "$_ts_line3" "$_ts_line4")
  test_equals "$_ts_pure" "$_ts_expected"
}

test "tree shake: includes str_before" {
  _ts_str=$("$_shsh" build <<'SHSH'
str_before "a:b" ":"
echo $R
SHSH
)
  if str_contains "$_ts_str" "str_before()"
    test_pass
  else
    test_fail "should include str_before"
  end
}

test "tree shake: excludes str_after" {
  _ts_str=$("$_shsh" build <<'SHSH'
str_before "a:b" ":"
echo $R
SHSH
)
  if str_contains "$_ts_str" "str_after()"
    test_fail "should not include str_after"
  else
    test_pass
  end
}

test "tree shake: excludes array_add" {
  _ts_str=$("$_shsh" build <<'SHSH'
str_before "a:b" ":"
echo $R
SHSH
)
  if str_contains "$_ts_str" "array_add()"
    test_fail "should not include array_add"
  else
    test_pass
  end
}

test "tree shake: includes array_add or inlines" {
  _ts_dep=$("$_shsh" build <<'SHSH'
array_add items "x"
SHSH
)
  # With static optimization, array_add is inlined for literal names
  if str_contains "$_ts_dep" "array_add()" || str_contains "$_ts_dep" "__shsh_items_"
    test_pass
  else
    test_fail "should include array_add or inline it"
  end
}

test "tree shake: includes dependency or inlines" {
  _ts_dep=$("$_shsh" build <<'SHSH'
array_add items "x"
SHSH
)
  # With static optimization, no runtime dependency needed for literal names
  if str_contains "$_ts_dep" "_shsh_check_name()" || str_contains "$_ts_dep" "__shsh_items_"
    test_pass
  else
    test_fail "should include _shsh_check_name or inline"
  end
}

test "tree shake: includes _shsh_sq for tokenize" {
  _ts_tok=$("$_shsh" build <<'SHSH'
tokenize "(a)" t
SHSH
)
  if str_contains "$_ts_tok" "_shsh_sq="
    test_pass
  else
    test_fail "should include _shsh_sq for tokenize"
  end
}

test "tree shake: includes _shsh_dq for tokenize" {
  _ts_tok=$("$_shsh" build <<'SHSH'
tokenize "(a)" t
SHSH
)
  if str_contains "$_ts_tok" "_shsh_dq="
    test_pass
  else
    test_fail "should include _shsh_dq for tokenize"
  end
}

test "tree shake: excludes _shsh_sq when unused" {
  _ts_noq=$("$_shsh" build <<'SHSH'
str_before "a:b" ":"
SHSH
)
  if str_contains "$_ts_noq" "_shsh_sq="
    test_fail "should not include _shsh_sq"
  else
    test_pass
  end
}

test "tree shake: includes ENDIAN for bit_16" {
  _ts_bit=$("$_shsh" build <<'SHSH'
bit_16 0x1234
SHSH
)
  if str_contains "$_ts_bit" "ENDIAN="
    test_pass
  else
    test_fail "should include ENDIAN for bit_16"
  end
}

test "tree shake: excludes ENDIAN when unused" {
  _ts_noend=$("$_shsh" build <<'SHSH'
array_add x "y"
SHSH
)
  if str_contains "$_ts_noend" "ENDIAN="
    test_fail "should not include ENDIAN"
  else
    test_pass
  end
}

test "tree shake: multi includes str_before" {
  _ts_multi=$("$_shsh" build <<'SHSH'
str_before "a:b" ":"
str_after "a:b" ":"
map_set m k v
SHSH
)
  if str_contains "$_ts_multi" "str_before()"
    test_pass
  else
    test_fail "multi should include str_before"
  end
}

test "tree shake: multi includes str_after" {
  if str_contains "$_ts_multi" "str_after()"
    test_pass
  else
    test_fail "multi should include str_after"
  end
}

test "tree shake: multi includes map_set or inlines" {
  # With static optimization, map_set is inlined for literal names/keys
  if str_contains "$_ts_multi" "map_set()" || str_contains "$_ts_multi" "__shsh_map_m_k="
    test_pass
  else
    test_fail "multi should include map_set or inline it"
  end
}

test "tree shake: includes transitive dep or inlines" {
  # With static optimization, no transitive dependency needed for inlined code
  if str_contains "$_ts_multi" "_shsh_sane()" || str_contains "$_ts_multi" "__shsh_map_m_k="
    test_pass
  else
    test_fail "should include transitive dep or inline"
  end
}

test "tree shake: stripped script runs" {
  _ts_run_src='
array_add nums 10
array_add nums 20
array_add nums 30
array_len nums
echo "len=$R"
array_get nums 1
echo "val=$R"
'
  _ts_run_out=$("$_shsh" build <<SHSH
$_ts_run_src
SHSH
)
  _ts_run_result=$(echo "$_ts_run_out" | sh)
  test_equals "$_ts_run_result" "len=3
val=20"
}

test "tree shake: map script runs" {
  _ts_map_out=$("$_shsh" build <<'SHSH'
map_set conf host "localhost"
map_set conf port "8080"
map_get conf host
echo "host=$R"
if map_has conf port
  echo "has port"
end
SHSH
)
  _ts_map_result=$(echo "$_ts_map_out" | sh)
  test_equals "$_ts_map_result" "host=localhost
has port"
}

test "tree shake: string script runs" {
  _ts_str_out=$("$_shsh" build <<'SHSH'
str_before "hello:world" ":"
a="$R"
str_after "hello:world" ":"
b="$R"
str_trim "  spaced  "
c="$R"
echo "$a|$b|$c"
SHSH
)
  _ts_str_result=$(echo "$_ts_str_out" | sh)
  test_equals "$_ts_str_result" "hello|world|spaced"
}

test "tree shake: no blank lines" {
  _ts_blank=$("$_shsh" build <<'SHSH'
str_before "x:y" ":"
SHSH
)
  _ts_blank_lines=$(printf '%s\n' "$_ts_blank" | grep -c '^$' || true)
  if "$_ts_blank_lines" == "0"
    test_pass
  else
    test_fail "has $_ts_blank_lines blank lines"
  end
}

test "tree shake: complex script runs" {
  _ts_complex=$("$_shsh" build <<'SHSH'
default host "localhost"
array_add items "one"
array_add items "two"
cb() { echo "item: $R"; }
array_for items cb
map_set cfg key "value"
map_get cfg key
echo "cfg=$R"
SHSH
)
  _ts_complex_result=$(echo "$_ts_complex" | sh)
  test_equals "$_ts_complex_result" "item: one
item: two
cfg=value"
}

test "tree shake: no stray fi" {
  _ts_fi=$("$_shsh" build <<'SHSH'
echo "hello"
SHSH
)
  if str_starts "$_ts_fi" "fi"
    test_fail "output starts with fi"
  else
    test_pass
  end
}

test "tree shake: while/done preserved in functions" {
  _ts_while=$("$_shsh" build <<'SHSH'
array_add nums 1
array_add nums 2
cb() { echo "$R"; }
array_for nums cb
SHSH
)
  if str_contains "$_ts_while" "while" && str_contains "$_ts_while" "done"
    test_pass
  else
    test_fail "while/done missing from array_for"
  end
}

test "tree shake: case/esac preserved in functions" {
  _ts_case=$("$_shsh" build <<'SHSH'
str_starts "hello" "he"
echo $?
SHSH
)
  if str_contains "$_ts_case" "case" && str_contains "$_ts_case" "esac"
    test_pass
  else
    test_fail "case/esac missing from str_starts"
  end
}

test "tree shake: top-level if excluded" {
  _ts_topif=$("$_shsh" build <<'SHSH'
str_before "a:b" ":"
echo $R
SHSH
)
  # Skip the dash auto-switch line, count only other top-level ifs
  _ts_topif_lines=$(printf '%s\n' "$_ts_topif" | grep -v '_SHSH_DASH' | grep -c "^if \[" || true)
  test_equals "$_ts_topif_lines" "0"
}

test "tree shake: function with internal if preserved" {
  _ts_funcif=$("$_shsh" build <<'SHSH'
tmp_file
echo $R
SHSH
)
  if str_contains "$_ts_funcif" 'if [' && str_contains "$_ts_funcif" "fi"
    test_pass
  else
    test_fail "internal if/fi missing from tmp_file"
  end
}

echo
echo "=== Inline Control Structures ==="

test "inline for basic" {
  _ilf=""
  for i in a b c: _ilf="$_ilf$i"; end
  test_equals "$_ilf" "abc"
}

test "inline for with numbers" {
  _ilfn=0
  for n in 1 2 3 4 5: _ilfn=$((_ilfn + n)); end
  test_equals "$_ilfn" "15"
}

test "inline for single item" {
  _ilfs=""
  for x in only: _ilfs="$x"; end
  test_equals "$_ilfs" "only"
}

test "inline while basic" {
  _ilw=0
  _ilwi=0
  while $_ilwi < 5: _ilw=$((_ilw + 1)); _ilwi=$((_ilwi + 1)); end
  test_equals "$_ilw" "5"
}

test "inline while with ++" {
  _ilwp=0
  while $_ilwp < 3: _ilwp++; end
  test_equals "$_ilwp" "3"
}

test "semicolon before inline for" {
  _sbif=""; for i in x y z: _sbif="$_sbif$i"; end
  test_equals "$_sbif" "xyz"
}

test "semicolon before inline while" {
  _sbiw=0; while $_sbiw < 4: _sbiw++; end
  test_equals "$_sbiw" "4"
}

test "inline for preserves quoting" {
  _ilfq=""
  for item in "a b" "c d": _ilfq="$_ilfq[$item]"; end
  test_equals "$_ilfq" "[a b][c d]"
}

test "inline while with string comparison" {
  _ilws="start"
  _ilwsc=0
  while "$_ilws" != "done" && $_ilwsc < 3: _ilwsc++; _ilws="done"; end
  test_equals "$_ilwsc" "1"
}

test "inline for inside regular for" {
  _nir=""
  for outer in 1 2
    for inner in a b: _nir="$_nir$outer$inner"; end
  end
  test_equals "$_nir" "1a1b2a2b"
}

test "inline while inside regular while" {
  _niw=""
  _niwo=0
  while $_niwo < 2
    _niwi=0
    while $_niwi < 2: _niw="$_niw$_niwo$_niwi"; _niwi++; end
    _niwo++
  end
  test_equals "$_niw" "00011011"
}

test "inline for with command substitution" {
  _ilfcs=""
  for f in $(echo "p q r"): _ilfcs="$_ilfcs$f"; end
  test_equals "$_ilfcs" "pqr"
}

test "inline while countdown" {
  _ilwcd=5
  _ilwcdr=""
  while $_ilwcd > 0: _ilwcdr="$_ilwcdr$_ilwcd"; _ilwcd=$((_ilwcd - 1)); end
  test_equals "$_ilwcdr" "54321"
}

test "multiple inline loops on separate lines" {
  _mil1=""; for a in 1 2: _mil1="$_mil1$a"; end
  _mil2=""; for b in 3 4: _mil2="$_mil2$b"; end
  test_equals "$_mil1$_mil2" "1234"
}

test "inline for with glob pattern in quotes" {
  _ilfg=""
  for p in "*.txt" "*.sh": _ilfg="$_ilfg$p "; end
  test_equals "$_ilfg" "*.txt *.sh "
}

test "inline while false never executes" {
  _ilwf="unchanged"
  while false: _ilwf="changed"; end
  test_equals "$_ilwf" "unchanged"
}

test "inline for empty list" {
  _ilfe="unchanged"
  for x in : _ilfe="changed"; end
  test_equals "$_ilfe" "unchanged"
}

test "pipe into inline while" {
  _piw=""
  echo -e "a\nb\nc" | while read _piwl: _piw="$_piw$_piwl"; end
  # Note: pipe creates subshell, so _piw won't be set in parent
  # This tests that the syntax works, not the value
  test_pass
}

test "inline while with complex condition" {
  _ilwcc=0
  _ilwcca=1
  _ilwccb=1
  while $_ilwcca == 1 && $_ilwccb == 1 && $_ilwcc < 3: _ilwcc++; end
  test_equals "$_ilwcc" "3"
}

test "chained inline statements" {
  _cis=0; _cis++
  for i in 1 2: _cis=$((_cis + i)); end
  _cis++
  test_equals "$_cis" "5"
}


# Nested inline control structures are not yet supported
# test "inline for with break simulation" {
#   _ilfb=""
#   for i in 1 2 3 4 5: if $i == 3: _ilfb="$_ilfb!"; end; _ilfb="$_ilfb$i"; end
#   test_equals "$_ilfb" "12!345"
# }

# test "inline if inside inline for" {
#   _iiif=""
#   for n in 1 2 3 4: if $n > 2: _iiif="$_iiif$n"; end; end
#   test_equals "$_iiif" "34"
# }

echo
echo "========================================"
echo "passed: $_shsh_test_pass"
echo "failed: $_shsh_test_fail"
if $_shsh_test_fail == 0
  echo "all tests passed!"
else
  exit 1
end

